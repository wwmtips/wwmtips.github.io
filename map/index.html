<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>연운 한국어 맵 for Wiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    
    <link rel="icon" type="image/png" sizes="32x32" href="../fav/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../fav/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="57x57" href="../fav/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../fav/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../fav/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../fav/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../fav/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../fav/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../fav/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../fav/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../fav/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="../fav/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="../fav/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="../fav/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="../fav/favicon-16x16.png">
<link rel="manifest" href="../fav/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="fav/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

    <style>
        /* =========================================
           1. 기본 설정
           ========================================= */
        * { font-family: 'Noto Sans KR', sans-serif !important; box-sizing: border-box; }
        body { margin: 0; padding: 0; background-color: #0e0e0e; overflow: hidden; }
        #map { width: 100vw; height: 100vh; background: #0e0e0e; z-index: 1; }
        .dev-mode-cursor { cursor: crosshair !important; }

        .leaflet-image-layer {
            filter: brightness(0.6) contrast(1.2) saturate(0.85);
            transition: filter 0.5s ease;
        }

        /* UI 컨테이너 */
        .top-left-controls, .top-right-controls, 
        .bottom-left-controls, .bottom-right-controls, .bottom-center-controls,
        .dev-controls { /* Dev 컨트롤 추가 */
            position: fixed; z-index: 90000 !important; 
            pointer-events: none !important; 
            display: flex; flex-direction: column; gap: 8px;
        }/* [수정] 개발자 모드 상태 표시기 (리스트형) */
        .dev-status-box {
            background: rgba(0, 0, 0, 0.85); 
            border: 1px solid #a08040;
            color: #ddd;
            padding: 8px 15px; 
            border-radius: 20px; 
            font-size: 12px; 
            font-weight: 500;
            display: none; /* 기본 숨김 */
            align-items: center; 
            white-space: nowrap; /* 줄바꿈 방지 */
            max-width: 60vw; /* 화면 너무 차지하지 않게 */
            overflow-x: auto; /* 내용 넘치면 스크롤 */
            gap: 10px;
        }
        /* 스크롤바 숨김 (깔끔하게) */
        .dev-status-box::-webkit-scrollbar { display: none; }
        
        .dev-type-tag {
            color: #fff;
            font-weight: 700;
        }
        .dev-type-count {
            color: #a08040;
            margin-left: 2px;
        }
        .dev-highlight { color: #a08040; font-weight: 800; }
        .top-left-controls { top: 15px; left: 15px; }
        .top-right-controls { top: 15px; right: 15px; }
        .bottom-left-controls { bottom: 25px; left: 15px; overflow: visible; }
        .bottom-right-controls { bottom: 25px; right: 15px; align-items: flex-end; }
        
        .bottom-center-controls {
            bottom: 25px; left: 70px; right: 70px;
            justify-content: center; align-items: center;
        }

        /* ★ [New] 개발자 패널 스타일 */
        .dev-controls {
            top: 15px; left: 50%; transform: translateX(-50%);
            flex-direction: row; display: none; /* 기본 숨김 */
        }
        .dev-controls.active { display: flex; }
        
        .dev-btn {
            background: rgba(0, 0, 0, 0.8); border: 1px solid #ff4444; color: #ff4444;
            padding: 8px 15px; border-radius: 20px; font-weight: 700; font-size: 12px;
            cursor: pointer; pointer-events: auto !important;
            display: flex; align-items: center; gap: 5px;
        }
        .dev-btn.recording { background: #ff4444; color: white; animation: pulse 1.5s infinite; }
        .dev-btn:hover { transform: scale(1.05); }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        /* 공통 클릭 활성화 */
        .glass-box, .glass-select, .glass-group-btn, .glass-single-btn,
        .sidebar-search-input, .panel-close-btn, .path-item, .search-result-row, 
        .filter-control-btn, .filter-item, .action-btn, 
        .search-panel, .filter-panel, .path-panel, 
        .save-load-popup, .popup-item {
            pointer-events: auto !important;
            cursor: pointer !important;
        }

        /* 패널 Z-index */
        .search-panel, .filter-panel, .path-panel { z-index: 100001 !important; }

        /* =========================================
           2. UI 디자인 (Glass Style)
           ========================================= */
        .glass-select {
            appearance: none; -webkit-appearance: none; background-color: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.2);
            color: #a08040; padding: 8px 28px 8px 12px; border-radius: 10px;
            font-weight: 700; font-size: 13px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23a08040%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat; background-position: right 10px top 50%; background-size: 8px auto;
        }
        .glass-select option { background-color: #1a1a1a; color: white; }

        .glass-box {
            width: 38px; height: 38px; background-color: rgba(20, 20, 20, 0.85); backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            color: #a08040; box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: all 0.2s;
        }
        .glass-box:hover { background-color: rgba(40, 40, 40, 0.95); border-color: #a08040; transform: scale(1.05); }

        #path-toggle-btn {
            width: 100%; max-width: 400px; height: 42px; padding: 0 20px; 
            border-radius: 21px; gap: 8px;
            background-color: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        #path-toggle-btn span { font-size: 13px; font-weight: 700; color: #ccc; letter-spacing: 0.5px; }
        
        #path-toggle-btn.path-active {
            background-color: #a08040 !important; border-color: #fff !important;
            box-shadow: 0 0 20px rgba(160, 128, 64, 0.6); transform: translateY(-2px);
        }
        #path-toggle-btn.path-active span, #path-toggle-btn.path-active svg { color: #fff !important; fill: #fff !important; }

        .glass-group {
            display: flex; flex-direction: column; background-color: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .glass-group-btn {
            width: 38px; height: 38px; display: flex; align-items: center; justify-content: center;
            color: #a08040; border-bottom: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.2s;
        }
        .glass-group-btn:last-child { border-bottom: none; }
        .glass-group-btn:hover { background-color: rgba(40, 40, 40, 0.95); color: #fff; } 
        
        .glass-single-btn {
            width: 38px; height: 38px; background-color: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px; display: flex; align-items: center; justify-content: center;
            color: #a08040; box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: all 0.2s;
        }
        .glass-single-btn:hover { background-color: rgba(40, 40, 40, 0.95); border-color: #a08040; color: #fff; transform: scale(1.05); }
        .icon-svg { width: 20px; height: 20px; fill: currentColor; }

        .save-load-popup {
            position: absolute; bottom: 50px; left: 0;
            background-color: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px; padding: 5px;
            display: flex; flex-direction: column; gap: 2px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 140px;
            opacity: 0; transform: translateY(10px) scale(0.95); pointer-events: none !important;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            transform-origin: bottom left;
        }
        .save-load-popup.active { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto !important; }

        .popup-item {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 12px; border-radius: 8px;
            color: #ccc; font-size: 13px; font-weight: 500;
            transition: background 0.2s;
        }
        .popup-item:hover { background-color: rgba(255,255,255,0.1); color: #fff; }
        .popup-item svg { width: 18px; height: 18px; fill: #a08040; }

        /* =========================================
           3. 핀 & 클러스터
           ========================================= */
        .pin-marker {
            position: relative; width: 100%; height: 100%;
            border-radius: 50% 50% 50% 0; transform: rotate(-45deg);
            background: #ffffff; 
            box-shadow: 1px 1px 5px rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
        }
        .pin-inner-circle {
            width: 88%; height: 88%; border-radius: 50%;
            background: var(--pin-color, #555);
            display: flex; align-items: center; justify-content: center;
        }
        .pin-inner-circle img {
            width: 70%; height: 70%; object-fit: contain; 
            transform: rotate(45deg); opacity: 1; filter: none;
        }
        .pin-marker:hover { transform: rotate(-45deg) scale(1.2); z-index: 9999; }
        .marker-completed .pin-inner-circle { background: #555 !important; }
        .marker-completed .pin-marker { opacity: 0.5; filter: grayscale(100%); }

        /* Dev 모드 선택된 마커 (반짝임) */
        .dev-selected .pin-marker {
            background-color: #00e5ff !important;
            transform: rotate(-45deg) scale(1.1);
            box-shadow: 0 0 10px #00e5ff;
        }

        .simple-cluster-marker {
            width: 100%; height: 100%; border-radius: 50%; 
            border: 2px solid #ffffff; color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 13px; font-weight: 800;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

        /* =========================================
           4. 경로 마커
           ========================================= */
        .path-marker-box {
            position: relative; width: 100%; height: 100%;
            background-color: #1c1c1c; border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0,0,0,0.6);
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s, filter 0.2s; 
        }
        .path-marker-box:hover { transform: scale(1.15); border-color: #a08040; z-index: 9999; }
        .path-marker-icon {
            width: 60%; height: 60%; object-fit: contain;
            filter: brightness(0) saturate(100%) invert(56%) sepia(87%) saturate(357%) hue-rotate(6deg) brightness(89%) contrast(89%);
        }
        .path-order-badge {
            position: absolute; bottom: -5px; right: -5px;
            background-color: #a08040; color: #fff;
            font-size: 10px; font-weight: 800; width: 18px; height: 18px;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            border: 2px solid #1c1c1c; box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .gateway-marker .path-marker-box { border-color: #00e5ff !important; box-shadow: 0 0 10px rgba(0, 229, 255, 0.4); }
        .gateway-marker .path-order-badge { background-color: #00e5ff !important; color: #000 !important; }
        .marker-completed .path-marker-box {
            background-color: #333 !important; border-color: #555 !important;
            filter: grayscale(100%) brightness(0.7); opacity: 0.8;
        }
        .marker-completed .path-order-badge { background-color: #555 !important; }

        /* =========================================
           5. 패널 스타일
           ========================================= */
        .search-panel, .filter-panel, .path-panel {
            position: fixed; top: 0; left: 0; width: 100%;
            background-color: rgba(20, 20, 20, 0.98); backdrop-filter: blur(10px);
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            display: flex; flex-direction: column;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .search-panel {
            padding: 15px 20px 20px 20px; box-sizing: border-box;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transform: translateY(-100%);
        }
        .search-panel.active { transform: translateY(0); }

        .filter-panel, .path-panel {
            top: auto; bottom: 0; max-height: 60vh;
            border-top: 1px solid rgba(255,255,255,0.1);
            border-top-left-radius: 20px; border-top-right-radius: 20px;
            padding-bottom: 20px; transform: translateY(100%);
        }
        .filter-panel.active, .path-panel.active { transform: translateY(0); }

        .panel-header {
            padding: 15px 20px; border-bottom: 1px solid #333;
            display: flex; align-items: center; justify-content: space-between;
        }
        .panel-title { color: white; font-weight: 700; font-size: 16px; }
        .panel-close-btn { color: #888; font-size: 24px; cursor: pointer; padding: 5px; }

        .path-list-container { padding: 10px 20px; overflow-y: auto; }
        .path-item {
            padding: 15px; background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px; display: flex; align-items: center; gap: 10px;
            transition: all 0.2s;
        }
        .path-item:hover { background-color: rgba(160, 128, 64, 0.2); border-color: #a08040; }
        .path-icon { width: 24px; height: 24px; fill: #a08040; flex-shrink: 0; }
        .path-name { color: #fff; font-weight: 700; font-size: 14px; }
        .path-desc { color: #aaa; font-size: 12px; margin-top: 2px; }

        .sidebar-search-input {
            width: 100%; padding: 12px 10px 12px 40px; 
            background-color: #333333 !important; border: 1px solid #a08040 !important;
            border-radius: 8px; color: #ffffff !important; font-size: 16px; 
            -webkit-appearance: none; outline: none;
        }
        .search-icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #a08040; font-size: 16px; }
        .search-wrapper { position: relative; width: 100%; margin-top: 15px; }
        
        .search-results-container {
            max-height: 60vh; overflow-y: auto; margin-top: 10px;
            background-color: rgba(30, 30, 30, 0.95) !important;
            border-radius: 8px; display: block !important;
        }
        .search-result-row {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 12px; border-bottom: 1px solid #444; cursor: pointer; gap: 12px;
        }
        .search-result-row:hover { background-color: rgba(255,255,255,0.05); }
        .result-info { flex: 1; overflow: hidden; display: flex; flex-direction: column; }
        .result-name { 
            color: #a08040; font-weight: 700; font-size: 14px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .result-desc { 
            color: #888; font-size: 11px; margin-top: 2px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .result-type-icon { width: 32px; height: 32px; object-fit: contain; flex-shrink: 0; opacity: 0.8; }

        .filter-controls { display: flex; gap: 6px; }
        .filter-control-btn {
            padding: 8px 12px; font-size: 11px; font-weight: 500;
            background-color: #333; border: 1px solid #555; color: #ccc; border-radius: 20px;
        }
        .filter-control-btn:hover { border-color: #a08040; color: #a08040; background-color: #252525; }
        .filter-list-container {
            padding: 10px 20px; overflow-y: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }
        .filter-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 5px; border-bottom: 1px solid #333;
        }
        .filter-left-group { display: flex; align-items: center; gap: 8px; flex: 1; }
        .filter-icon-img { width: 24px; height: 24px; object-fit: contain; }
        .filter-text-name { font-size: 13px; color: #aaa; }
        .filter-count { color: #666; font-size: 12px; }
        .filter-item.active .filter-text-name { color: #fff; font-weight: 700; }
        .filter-item.active .filter-icon-img { opacity: 1; filter: drop-shadow(0 0 2px rgba(255,255,255,0.5)); }
        .filter-item.inactive { opacity: 0.4; }

        @media (min-width: 768px) {
            .search-panel, .filter-panel, .path-panel { max-width: 400px; left: 50%; transform: translateX(-50%); }
            .search-panel { transform: translateX(-50%) translateY(-100%); border-radius: 0 0 20px 20px; }
            .search-panel.active { transform: translateX(-50%) translateY(0); }
            .filter-panel, .path-panel { transform: translateX(-50%) translateY(100%); }
            .filter-panel.active, .path-panel.active { transform: translateX(-50%) translateY(0); }
        }
     
     
        /* =========================================
           1. 기본 설정 및 클릭 문제 해결
           ========================================= */
        * { font-family: 'Noto Sans KR', sans-serif !important; box-sizing: border-box; }
        body { margin: 0; padding: 0; background-color: #0e0e0e; overflow: hidden; }
        #map { width: 100vw; height: 100vh; background: #0e0e0e; z-index: 1; }
        .dev-mode-cursor { cursor: crosshair !important; }

        .leaflet-image-layer {
            filter: brightness(0.6) contrast(1.2) saturate(0.85);
            transition: filter 0.5s ease;
        }

        /* UI 컨테이너 (클릭 통과) */
        .top-left-controls, .top-right-controls, 
        .bottom-left-controls, .bottom-right-controls, .bottom-center-controls {
            position: fixed; z-index: 90000 !important; 
            pointer-events: none !important; 
            display: flex; flex-direction: column; gap: 8px;
        }

        .top-left-controls { top: 15px; left: 15px; }
        .top-right-controls { top: 15px; right: 15px; }
        .bottom-left-controls { bottom: 25px; left: 15px; overflow: visible; }
        .bottom-right-controls { bottom: 25px; right: 15px; align-items: flex-end; }
        
        .bottom-center-controls {
            bottom: 25px; left: 70px; right: 70px;
            justify-content: center; align-items: center;
        }
        
        /* 클릭 활성화 대상 */
        .glass-box, .glass-select, .glass-group-btn, .glass-single-btn,
        .sidebar-search-input, .panel-close-btn, .path-item, .search-result-row, 
        .filter-control-btn, .filter-item, .action-btn, 
        .search-panel, .filter-panel, .path-panel, 
        .save-load-popup, .popup-item {
            pointer-events: auto !important;
            cursor: pointer !important;
        }

        /* 패널 Z-index */
        .search-panel, .filter-panel, .path-panel {
            z-index: 100001 !important;
        }

        /* =========================================
           2. UI 디자인 (Glass Style)
           ========================================= */
        .glass-select {
            appearance: none; -webkit-appearance: none; background-color: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.2);
            color: #a08040; padding: 8px 28px 8px 12px; border-radius: 10px;
            font-weight: 700; font-size: 13px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23a08040%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat; background-position: right 10px top 50%; background-size: 8px auto;
        }
        .glass-select option { background-color: #1a1a1a; color: white; }

        .glass-box {
            width: 38px; height: 38px; background-color: rgba(20, 20, 20, 0.85); backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            color: #a08040; box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: all 0.2s;
        }
        .glass-box:hover { background-color: rgba(40, 40, 40, 0.95); border-color: #a08040; transform: scale(1.05); }

        #path-toggle-btn {
            width: 100%; max-width: 400px; height: 42px; padding: 0 20px; 
            border-radius: 21px; gap: 8px;
            background-color: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        #path-toggle-btn span { font-size: 13px; font-weight: 700; color: #ccc; letter-spacing: 0.5px; }
        
        #path-toggle-btn.path-active {
            background-color: #a08040 !important; border-color: #fff !important;
            box-shadow: 0 0 20px rgba(160, 128, 64, 0.6); transform: translateY(-2px);
        }
        #path-toggle-btn.path-active span, #path-toggle-btn.path-active svg { color: #fff !important; fill: #fff !important; }

        .glass-group {
            display: flex; flex-direction: column; background-color: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .glass-group-btn {
            width: 38px; height: 38px; display: flex; align-items: center; justify-content: center;
            color: #a08040; border-bottom: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.2s;
        }
        .glass-group-btn:last-child { border-bottom: none; }
        .glass-group-btn:hover { background-color: rgba(40, 40, 40, 0.95); color: #fff; } 
        
        .glass-single-btn {
            width: 38px; height: 38px; background-color: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px; display: flex; align-items: center; justify-content: center;
            color: #a08040; box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: all 0.2s;
        }
        .glass-single-btn:hover { background-color: rgba(40, 40, 40, 0.95); border-color: #a08040; color: #fff; transform: scale(1.05); }
        .icon-svg { width: 20px; height: 20px; fill: currentColor; }

        /* 저장/불러오기 팝업 메뉴 */
        .save-load-popup {
            position: absolute; bottom: 50px; left: 0;
            background-color: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 5px;
            display: flex; flex-direction: column; gap: 2px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 140px;
            opacity: 0; transform: translateY(10px) scale(0.95); pointer-events: none !important;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            transform-origin: bottom left;
        }
        .save-load-popup.active { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto !important; }

        .popup-item {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 12px; border-radius: 8px;
            color: #ccc; font-size: 13px; font-weight: 500;
            transition: background 0.2s;
        }
        .popup-item:hover { background-color: rgba(255,255,255,0.1); color: #fff; }
        .popup-item svg { width: 18px; height: 18px; fill: #a08040; }

        /* =========================================
           3. 핀 & 클러스터
           ========================================= */
        .pin-marker {
            position: relative; width: 100%; height: 100%;
            border-radius: 50% 50% 50% 0; transform: rotate(-45deg);
            background: #ffffff; 
            box-shadow: 1px 1px 5px rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
        }
        .pin-inner-circle {
            width: 88%; height: 88%; border-radius: 50%;
            background: var(--pin-color, #555);
            display: flex; align-items: center; justify-content: center;
        }
        .pin-inner-circle img {
            width: 70%; height: 70%; object-fit: contain; 
            transform: rotate(45deg); opacity: 1; filter: none;
        }
        .pin-marker:hover { transform: rotate(-45deg) scale(1.2); z-index: 9999; }
        .marker-completed .pin-inner-circle { background: #555 !important; }
        .marker-completed .pin-marker { opacity: 0.5; filter: grayscale(100%); }

        .simple-cluster-marker {
            width: 100%; height: 100%; border-radius: 50%; 
            border: 2px solid #ffffff; color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 13px; font-weight: 800;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

        /* =========================================
           4. 경로 마커
           ========================================= */
        .path-marker-box {
            position: relative; width: 100%; height: 100%;
            background-color: #1c1c1c; border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0,0,0,0.6);
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s, filter 0.2s; 
        }
        .path-marker-box:hover { transform: scale(1.15); border-color: #a08040; z-index: 9999; }
        .path-marker-icon {
            width: 60%; height: 60%; object-fit: contain;
            filter: brightness(0) saturate(100%) invert(56%) sepia(87%) saturate(357%) hue-rotate(6deg) brightness(89%) contrast(89%);
        }
        .path-order-badge {
            position: absolute; bottom: -5px; right: -5px;
            background-color: #a08040; color: #fff;
            font-size: 10px; font-weight: 800; width: 18px; height: 18px;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            border: 2px solid #1c1c1c; box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .gateway-marker .path-marker-box { border-color: #00e5ff !important; box-shadow: 0 0 10px rgba(0, 229, 255, 0.4); }
        .gateway-marker .path-order-badge { background-color: #00e5ff !important; color: #000 !important; }
        .marker-completed .path-marker-box {
            background-color: #333 !important; border-color: #555 !important;
            filter: grayscale(100%) brightness(0.7); opacity: 0.8;
        }
        .marker-completed .path-order-badge { background-color: #555 !important; }

        /* =========================================
           5. 패널 스타일
           ========================================= */
        .search-panel, .filter-panel, .path-panel {
            position: fixed; top: 0; left: 0; width: 100%;
            background-color: rgba(20, 20, 20, 0.98); backdrop-filter: blur(10px);
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            display: flex; flex-direction: column;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .search-panel {
            padding: 15px 20px 20px 20px; box-sizing: border-box;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transform: translateY(-100%);
        }
        .search-panel.active { transform: translateY(0); }

        .filter-panel, .path-panel {
            top: auto; bottom: 0; max-height: 60vh;
            border-top: 1px solid rgba(255,255,255,0.1);
            border-top-left-radius: 20px; border-top-right-radius: 20px;
            padding-bottom: 20px; transform: translateY(100%);
        }
        .filter-panel.active, .path-panel.active { transform: translateY(0); }

        .panel-header {
            padding: 15px 20px; border-bottom: 1px solid #333;
            display: flex; align-items: center; justify-content: space-between;
        }
        .panel-title { color: white; font-weight: 700; font-size: 16px; }
        .panel-close-btn { color: #888; font-size: 24px; cursor: pointer; padding: 5px; }

        .path-list-container { padding: 10px 20px; overflow-y: auto; }
        .path-item {
            padding: 15px; background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px; display: flex; align-items: center; gap: 10px;
            transition: all 0.2s;
        }
        .path-item:hover { background-color: rgba(160, 128, 64, 0.2); border-color: #a08040; }
        .path-icon { width: 24px; height: 24px; fill: #a08040; flex-shrink: 0; }
        .path-name { color: #fff; font-weight: 700; font-size: 14px; }
        .path-desc { color: #aaa; font-size: 12px; margin-top: 2px; }

        .sidebar-search-input {
            width: 100%; padding: 12px 10px 12px 40px; 
            background-color: #333333 !important; border: 1px solid #a08040 !important;
            border-radius: 8px; color: #ffffff !important; font-size: 16px; 
            -webkit-appearance: none; outline: none;
        }
        .search-icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #a08040; font-size: 16px; }
        .search-wrapper { position: relative; width: 100%; margin-top: 15px; }
        
        .search-results-container {
            max-height: 60vh; overflow-y: auto; margin-top: 10px;
            background-color: rgba(30, 30, 30, 0.95) !important;
            border-radius: 8px; display: block !important;
        }
        .search-result-row {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 10px; border-bottom: 1px solid #444; cursor: pointer;
        }
        .result-name { color: #a08040; font-weight: 700; font-size: 14px; }
        .result-desc { color: #ccc; font-size: 12px; margin-top: 2px; }

        .filter-controls { display: flex; gap: 6px; }
        .filter-control-btn {
            padding: 8px 12px; font-size: 11px; font-weight: 500;
            background-color: #333; border: 1px solid #555; color: #ccc; border-radius: 20px;
        }
        .filter-control-btn:hover { border-color: #a08040; color: #a08040; background-color: #252525; }
        .filter-list-container {
            padding: 10px 20px; overflow-y: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }
        .filter-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 5px; border-bottom: 1px solid #333;
        }
        .filter-left-group { display: flex; align-items: center; gap: 8px; flex: 1; }
        .filter-icon-img { width: 24px; height: 24px; object-fit: contain; }
        .filter-text-name { font-size: 13px; color: #aaa; }
        .filter-count { color: #666; font-size: 12px; }
        .filter-item.active .filter-text-name { color: #fff; font-weight: 700; }
        .filter-item.active .filter-icon-img { opacity: 1; filter: drop-shadow(0 0 2px rgba(255,255,255,0.5)); }
        .filter-item.inactive { opacity: 0.4; }

        /* 팝업 */
        .leaflet-popup-content-wrapper { 
            background: #ffffff !important; color: #333 !important; 
            border-radius: 12px !important; padding: 0 !important;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5) !important; overflow: hidden;
        }
        .leaflet-popup-content { margin: 0 !important; width: 280px !important; text-align: center; line-height: 1.5; }
        .leaflet-popup-tip { background: #ffffff !important; }
        .leaflet-container a.leaflet-popup-close-button {
            top: 8px !important; right: 8px !important; color: #666 !important; font-size: 20px !important; z-index: 10;
        }
        .popup-inner { padding: 20px 15px 15px 15px; }
        .popup-title { font-size: 18px; font-weight: 800; color: #111; margin-bottom: 5px; display: block; }
        .popup-type-badge { 
            display: inline-block; font-size: 11px; color: #fff; background-color: #a08040;
            font-weight: 700; padding: 2px 8px; border-radius: 10px; margin-bottom: 12px;
        }
        .popup-desc { 
            font-size: 14px; color: #444; background: #f5f5f7; 
            padding: 12px; border-radius: 8px; margin: 0 0 12px 0; 
            text-align: left; word-break: keep-all; line-height: 1.4;
        }
        .popup-img { 
            width: 100%; height: auto; max-height: 200px; object-fit: cover;
            border-radius: 8px; margin-bottom: 10px; display: block; border: 1px solid #eee;
        }
        .popup-youtube-container {
            position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; 
            margin-bottom: 10px; border-radius: 8px; background: #000;
        }
        .popup-youtube-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .btn-container { display: flex; gap: 8px; margin-top: 5px; }
        .action-btn { 
            flex: 1; padding: 10px 0; border-radius: 8px; font-size: 13px; font-weight: 700; 
            border: none; color: white; text-align: center; text-decoration: none; 
            display: flex; align-items: center; justify-content: center; gap: 4px;
        }
        .btn-wiki { background-color: #4a90e2; }
        .btn-complete { background-color: #2e7d32; }
        .btn-undo { background-color: #757575; }

        @media (min-width: 768px) {
            .search-panel, .filter-panel, .path-panel { max-width: 400px; left: 50%; transform: translateX(-50%); }
            .search-panel { transform: translateX(-50%) translateY(-100%); border-radius: 0 0 20px 20px; }
            .search-panel.active { transform: translateX(-50%) translateY(0); }
            .filter-panel, .path-panel { transform: translateX(-50%) translateY(100%); }
            .filter-panel.active, .path-panel.active { transform: translateX(-50%) translateY(0); }
        }

/* ★ [수정] 경로 요약 정보 바 - 화면 좌우 꽉 채우기 */
#path-summary-bar {
    display: none; /* 기본 숨김 */
    position: fixed; /* 위치 고정 */
    
    /* 위치: 하단 컨트롤들(저장, 경로버튼, 전체화면) 바로 위에 배치 */
    bottom: 80px; 
    
    /* 가로 너비: 저장 버튼 좌측(15px) ~ 전체화면 우측(15px) */
    left: 15px; 
    right: 15px;
    
    /* 레이아웃 */
    flex-direction: row; 
    justify-content: center; /* 내용 중앙 정렬 (원하시면 space-between 가능) */
    align-items: center;
    flex-wrap: wrap;
    gap: 15px;
    
    /* 디자인 */
    background-color: rgba(20, 20, 20, 0.95); 
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2); 
    padding: 12px 20px; 
    border-radius: 16px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    
    z-index: 90001; /* 다른 버튼보다 위에 */
    pointer-events: auto !important;
}

/* 요약 텍스트 스타일 */
.summary-chunk { 
    font-size: 14px; 
    font-weight: 500; 
    color: #ccc; 
    display: flex;
    align-items: center;
}
.summary-chunk b { 
    color: #a08040; 
    margin-left: 5px; 
    font-size: 15px;
}

/* =========================================
   ★ [Mobile Optimization] 경로 요약 바 모바일 최적화
   ========================================= */
@media (max-width: 768px) {
    #path-summary-bar {
        /* 1. 패널 크기 및 여백 축소 */
        padding: 6px 12px !important; 
        gap: 2px 10px !important; /* 아이템 간 간격 좁힘 */
        
        /* 2. 배경 투명도 조절 (0.95 -> 0.75) */
        background-color: rgba(20, 20, 20, 0.75) !important; 
        backdrop-filter: blur(5px) !important; /* 흐림 효과는 유지하되 약간 줄임 */
        
        /* 3. 테두리 및 둥글기 조절 */
        border-radius: 12px !important;
        border: 1px solid rgba(255, 255, 255, 0.15) !important;
        
        /* 4. 위치 미세 조정 (하단 버튼과 간격 확보) */
        bottom: 75px !important;
        left: 15px !important;
        right: 15px !important;
    }

    /* 5. 폰트 사이즈 대폭 축소 */
    .summary-chunk { 
        font-size: 11px !important; 
        line-height: 1.4 !important;
    }
    
    .summary-chunk b { 
        font-size: 12px !important; 
        margin-left: 3px !important;
    }
}
/* =========================================
   ★ [PC Optimization] 경로 모드 버튼 크기 확대
   ========================================= */
@media (min-width: 769px) {
    #path-toggle-btn {
     
        max-width: 80% !important;   /* 너비: 400px -> 500px */
        border-radius: 28px !important; /* 둥근 모서리도 비율에 맞게 조정 */
        
        /* 2. 여백 및 간격 조정 */
        padding: 0 30px !important;
        gap: 12px !important;
        
        /* 3. 살짝 위로 띄우기 (시각적 균형) */
        bottom: 35px !important; 
    }
    
    /* 4. 글자 크기 시원하게 */
    #path-toggle-btn span {
        font-size: 16px !important;    /* 글자: 13px -> 16px */
        letter-spacing: 1px !important;
    }
    
    /* 5. 아이콘 크기 확대 */
    #path-toggle-btn .icon-svg {
        width: 24px !important;        /* 아이콘: 20px -> 24px */
        height: 24px !important;
    }
}
/* =========================================
   3. 핀 & 클러스터 (다크 토큰 & 컬러 테두리)
   ========================================= */

/* --- [1] 개별 핀 스타일 --- *//* =========================================
           1. 핀 디자인 (다크 토큰 & 컬러 테두리)
           ========================================= */
        .pin-marker {
            position: relative; width: 100%; height: 100%;
            
            /* 1. 완전한 원형으로 변경 */
            border-radius: 50% !important;
            transform: none !important; /* 회전 제거 */
            
            /* 2. 배경: 지도와 어우러지는 반투명 검정 */
            background-color: rgba(20, 20, 20, 0.75);
            backdrop-filter: blur(2px);
            
            /* 3. 테두리: 카테고리 색상 적용 (JS에서 받은 변수 사용) */
            border: 2px solid var(--pin-color, #ffffff);
            box-sizing: border-box;
            
            /* 그림자 */
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s ease;
        }

        .pin-inner-circle {
            width: 100%; height: 100%;
            border-radius: 50%;
            /* 배경색 제거 (부모 배경 사용) */
            background: transparent !important;
            display: flex; align-items: center; justify-content: center;
        }

        .pin-inner-circle img {
            width: 65%; height: 65%;
            object-fit: contain;
            transform: none !important; /* 회전 제거 */
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.8));
            opacity: 1;
        }

        /* 호버 효과 */
        .pin-marker:hover {
            transform: scale(1.2);
            z-index: 9999; cursor: pointer;
            /* 빛나는 효과 */
            box-shadow: 0 0 10px var(--pin-color), 0 4px 8px rgba(0,0,0,0.5);
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* 완료된 마커 */
        .marker-completed .pin-marker { 
            opacity: 0.5; 
            filter: grayscale(1.0);
            border-color: #555 !important;
        }
        /* --- [2] 클러스터 스타일 (핀과 통일) --- */
/* =========================================
   4. 심플 클러스터 (다크 토큰 스타일 - 핀과 통일)
   ========================================= */
.simple-cluster-marker {
    width: 100%; height: 100%;
    
    /* 1. 모양: 완전한 원형 */
    border-radius: 50% !important;
    
    /* 2. 배경: 핀과 동일한 반투명 검정 (지도가 비침) */
    background-color: rgba(20, 20, 20, 0.75) !important;
    backdrop-filter: blur(2px);
    
    /* 3. 테두리: JS에서 받은 카테고리 색상 적용 */
    /* 변수가 없으면 기본값으로 흰색(#fff) 사용 */
    border: 2px solid var(--cluster-color, #ffffff00) !important;
    box-sizing: border-box;
    
    /* 4. 글자: 흰색 + 그림자 */
    color: #ffffff !important;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    font-size: 12px; 
    font-weight: 800;
    font-family: 'Noto Sans KR', sans-serif;
    
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    transition: transform 0.2s ease;
}

/* 호버 효과 */
.simple-cluster-marker:hover {
    transform: scale(1.15); 
    z-index: 9999;
    
    /* 호버 시 배경 진해지고 테두리 빛남 */
    background-color: rgba(0, 0, 0, 0.9) !important;
    box-shadow: 0 0 10px var(--cluster-color), 0 2px 5px rgba(0,0,0,0.5);
}
/* =========================================
   6. 커스텀 스크롤바 디자인 (Dark Glass Style)
   ========================================= */

/* 스크롤바의 전체 너비 설정 */
.path-list-container::-webkit-scrollbar {
    width: 6px;  /* 얇고 세련되게 */
}

/* 스크롤바의 배경 (트랙) - 투명하게 처리 */
.path-list-container::-webkit-scrollbar-track {
    background: transparent; 
    margin: 5px 0; /* 위아래 여백 */
}

/* 스크롤바 핸들 (움직이는 막대) */
.path-list-container::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.15); /* 아주 연한 회색 */
    border-radius: 3px; /* 둥근 모서리 */
    transition: background-color 0.2s;
}

/* 스크롤바에 마우스를 올렸을 때 */
.path-list-container::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.3); /* 좀 더 밝게 강조 */
}

/* (선택사항) 검색창이나 필터창에도 똑같이 적용하려면 아래 셀렉터를 추가하세요 */
.search-results-container::-webkit-scrollbar,
.filter-list-container::-webkit-scrollbar {
    width: 6px;
}
.search-results-container::-webkit-scrollbar-track,
.filter-list-container::-webkit-scrollbar-track {
    background: transparent;
}
.search-results-container::-webkit-scrollbar-thumb,
.filter-list-container::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 3px;
}
.search-results-container::-webkit-scrollbar-thumb:hover,
.filter-list-container::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.3);
}
          /* [수정] 경로 리스트 컨테이너 */
        .path-list-container { 
            padding: 10px 15px; /* 패딩을 조금 줄임 */
            overflow-y: auto; 
            
            /* 2열 그리드 유지 */
            display: grid;
            grid-template-columns: 1fr 1fr; 
            gap: 8px; /* 간격을 좁게 설정 */
        }

        /* [수정] 경로 아이템 (얇은 가로형 스타일) */
        .path-item {
            /* 1. 크기 및 여백: 얇게 만듦 */
            padding: 10px 12px; 
            min-height: 0; /* 고정 높이 제거 */
            
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            
            /* 2. 배치: 가로 정렬 [아이콘] - [이름] */
            display: flex; 
            flex-direction: row; 
            align-items: center; 
            justify-content: flex-start; /* 왼쪽 정렬 */
            gap: 10px; /* 아이콘과 글자 사이 간격 */
            
            margin-bottom: 0;
            transition: all 0.2s;
            text-align: left; 
        }
        
        /* 호버 효과 */
        .path-item:hover { 
            background-color: rgba(160, 128, 64, 0.2); 
            border-color: #a08040; 
            transform: translateY(-1px); /* 살짝만 뜸 */
        }
        
        /* 아이콘 스타일 */
        .path-icon { 
            width: 16px; /* 아이콘 크기 축소 */
            height: 16px; 
            fill: #a08040; 
            flex-shrink: 0; 
            margin-bottom: 0; /* 마진 제거 */
        }
        
        /* 텍스트 스타일 */
        .path-name { 
            color: #e0e0e0; 
            font-weight: 500; 
            font-size: 13px; 
            line-height: 1.2;
            
            /* 이름이 길 경우 말줄임표(...) 처리 */
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis;
        }
        /* [수정] 메인 컨테이너 (그리드 제거, 스크롤만 담당) */
        .path-list-container { 
            padding: 10px 15px; 
            overflow-y: auto; 
            display: block; /* 그리드 제거 -> 블록 요소로 변경 */
        }

        /* [신규] 카테고리 헤더 스타일 */
        .path-category-header {
            font-size: 12px;
            font-weight: 700;
            color: #a08040; /* 금색 포인트 */
            margin: 15px 0 8px 2px; /* 위아래 여백 */
            display: flex;
            align-items: center;
        }
        /* 첫 번째 헤더는 위쪽 여백 줄임 */
        .path-category-header:first-child { margin-top: 5px; }

        /* [신규] 카테고리별 그리드 그룹 (여기에 2열 그리드 적용) */
        .path-category-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; /* 1:1 비율 2열 */
            gap: 8px;
        }

        /* [유지] 경로 아이템 (얇은 스타일 그대로 유지) */
        .path-item {
            padding: 10px 12px; 
            min-height: 0;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; 
            flex-direction: row; 
            align-items: center; 
            justify-content: flex-start;
            gap: 10px;
            text-align: left; 
            transition: all 0.2s;
        }
        .path-item:hover { 
            background-color: rgba(160, 128, 64, 0.2); 
            border-color: #a08040; 
            transform: translateY(-1px);
        }
        .path-icon { width: 16px; height: 16px; fill: #a08040; flex-shrink: 0; }
        .path-name { 
            color: #e0e0e0; font-weight: 500; font-size: 13px; line-height: 1.2;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

</style>
</head>
<body>

    <div class="top-left-controls">
        <select id="main-map-select" class="glass-select"></select>
    </div>

<div id="dev-panel" class="dev-controls">
        <div class="dev-btn" id="dev-record-btn" onclick="toggleDevRecording()">⚫ REC</div>
        <div class="dev-btn" onclick="copyDevPath()">📋 JSON (<span id="dev-count">0</span>)</div>
        
        <div id="dev-status" class="dev-status-box"></div>
    </div>

    <div class="top-right-controls">
        <div class="glass-box" onclick="togglePanel('search')" title="검색">
            <svg class="icon-svg" viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
        </div>
    </div>

    <div class="bottom-left-controls">
        <div id="save-load-menu" class="save-load-popup">
            <div class="popup-item" onclick="exportCompletedPins(); toggleSaveLoadMenu();">
                <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                <span>저장하기</span>
            </div>
            <div class="popup-item" onclick="document.getElementById('import-file').click(); toggleSaveLoadMenu();">
                <svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/></svg>
                <span>불러오기</span>
            </div>
        </div>
        <div class="glass-box" onclick="toggleSaveLoadMenu()" title="저장 관리">
            <svg class="icon-svg" viewBox="0 0 24 24">
                <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
            </svg>
        </div>
    </div>
    <input type="file" id="import-file" style="display:none" accept=".json" onchange="importCompletedPins(this)">

    <div class="bottom-center-controls">
         <div id="path-summary-bar"></div>
        <div id="path-toggle-btn" class="glass-box" onclick="handlePathButtonClick()" title="추천 경로">
            <svg class="icon-svg" viewBox="0 0 24 24">
                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
            </svg>
            <span>경로 모드</span>
        </div>
    </div>

    <div class="bottom-right-controls">
        <div class="glass-group">
            <div class="glass-group-btn" onclick="toggleClusterMode()" title="모아보기 토글">
                <svg class="icon-svg" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
            </div>
            <div class="glass-group-btn" onclick="togglePanel('filter')" title="필터">
                <svg class="icon-svg" viewBox="0 0 24 24"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/></svg>
            </div>
        </div>
        <div class="glass-single-btn" onclick="toggleFullscreen()" title="전체 화면">
            <svg class="icon-svg" viewBox="0 0 24 24"><path d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6z"/></svg>
        </div>
    </div>

    <div id="search-panel" class="search-panel">
        <div class="panel-close-btn" onclick="closeAllPanels()">✕</div>
        <div class="search-wrapper">
            <input type="text" id="marker-search" class="sidebar-search-input" placeholder="마커 이름 검색..." autocomplete="off">
            <span class="search-icon">🔍</span>
        </div>
        <div id="search-result-list" class="search-results-container"></div>
    </div>

    <div id="filter-panel" class="filter-panel">
        <div class="panel-header filter-header">
            <span class="panel-title filter-title">필터 설정</span>
            <div class="filter-controls">
                <button class="filter-control-btn" onclick="setAllFilters(true)">전체 켜기</button>
                <button class="filter-control-btn" onclick="setAllFilters(false)">전체 끄기</button>
            </div>
            <div class="panel-close-btn" onclick="closeAllPanels()">✕</div>
        </div>
        <div id="filter-list" class="filter-list-container"></div>
    </div>

        <div id="path-panel" class="path-panel">
        <div class="panel-header" style="border-bottom: none; padding-bottom: 5px;">
            <span class="panel-title">경로</span>
            <div class="panel-close-btn" onclick="closeAllPanels()">✕</div>
        </div>
        <div style="padding: 0 20px 15px 20px; color: #888; font-size: 12px; border-bottom: 1px solid rgba(255,255,255,0.1);">
            각 지역별 100% 달성 경로 입니다.
        </div>
        <div class="path-list-container" id="path-list-dynamic"></div>
    </div>


    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<script>
    // ★ [안전 모드] 샘플 데이터
    const sampleData = [
        { id: 101, name: "청하 상자 1", type: "기타", x: 2000, y: 3000, desc: "나무 아래" },
        { id: 102, name: "장군 사당 입구", type: "경계석", x: 2500, y: 3200, desc: "워프 포인트" },
        { id: 103, name: "숨겨진 보스", type: "보스", x: 3000, y: 1500, desc: "강력함" }
    ];
    
    const samplePathData = {
        "sample_route": {
            "title": "예시 경로 (샘플)",
            "desc": "데이터 로드 실패 시 보여지는 경로입니다.",
            "markers": [ { "id": 101, "map": "qinghe" }, { "id": 102, "map": "gesh" } ]
        }, "sample_route2": {
            "title": "예시 경로 (샘플)",
            "category":"채집",
            "desc": "데이터 로드 실패 시 보여지는 경로입니다.",
            "markers": [ { "id": 101, "map": "qinghe" }, { "id": 102, "map": "gesh" } ]
        }
    };

    // 맵 설정 데이터
    const mapsDB = {
        "qinghe": { name: "청하", img: "../map/images/qinghe.jpg", json: "../json/qinghe.json", w: 7306, h: 4732 },
        "gesh": { name: "장군 사당", img: "../map/images/gesh.jpg", json: "../json/gesh.json", w: 1662, h: 1787 },
        "drs": { name: "꿈속의 불선선", img: "../map/images/dream.jpg", json: "../json/drs.json", w: 4545, h: 2743 },
        "kaifeng": { name: "개봉", img: "../map/images/kaifeng.jpg", json: "../json/kaifeng.json", w: 5159, h: 7000 },
        "gm": { name: "귀문시장", img: "../map/images/gm.jpg", json: "../json/gm.json", w: 5482, h: 3534 }
    };

    // 타입 및 색상 매핑
    const typeMapping = { 
        "경계석": "ic_pin", "묘묘냥": "ic_mew", "고양이": "ic_cat",
        "만사록": "ic_mansa", "묘물": "ic_uni", "상자": "ic_chest", 
        "보스": "ic_boss", "기연": "ic_ki", "천지록": "ic_cj","사건":"ic_pvp",
        "낚시대결":"ic_fish","투호대결":"ic_two","영지":"ic_camp","강호의벗":"ic_pic","유물":"ic_tr",
        "탐방":"logo","만물의울림":"ic_man","곡경심유":"ic_gk","궁술대결":"logo","기타":"logo","야외제사":"logo",
        "무술로맺은인연":"logo", 
        "풍류의선률":"logo",
        "의술치유":"logo", 
        "상기":"logo", 
        "엽자희":"logo", 
        "채집":"ic_fw"
    };

       const colorMapping = {
        "상자": "#4CAF50", // 밝은 초록
        "보스": "#F44336", // 밝은 빨강
        "고양이": "#607D8B", // 파란 회색 (검정은 너무 어두워서 변경)
        "묘물": "#009688", // 밝은 청록
        "만사록": "#FF9800", // 주황
        "경계석": "#9C27B0", // 밝은 보라
        "기연": "#E91E63", // 진한 분홍
        "묘묘냥": "#673AB7", // 짙은 보라
        "천지록": "#2196F3", // 밝은 파랑
        "사건": "#3F51B5",
        "낚시대결":"#272a57",
        "투호대결":"#272a57",
        "영지":"#d8d5a8",
        "강호의벗":"#fbceb1",
        "유물":"#003458",
        "탐방":"#fbceb1",
        "상기":"#fbceb1", 
        "엽자희":"#fbceb1",
        "만물의울림":"#fbceb1","곡경심유":"#fbceb1","궁술대결":"#fbceb1","기타":"#fbceb1","야외제사":"#fbceb1",
        "무술로맺은인연":"#fbceb1", "화술논쟁":"#fbceb1", "풍류의선률":"#fbceb1", "의술치유":"#fbceb1", "채집":"#b1fbba",
        "엽자희":"#b1fbba"
        
    };



    // URL 파라미터 처리
    const urlParams = new URLSearchParams(window.location.search);
    let rawId = urlParams.get('id') || "qinghe";
    const isDevMode = rawId.endsWith('_dev');
    let currentMapId = isDevMode ? rawId.replace('_dev', '') : rawId;

    if (!mapsDB[currentMapId]) currentMapId = "qinghe";
    const currentConfig = mapsDB[currentMapId];
    
    document.title = `${currentConfig.name} - 연운 지도`;

    // 맵 초기화
    const map = L.map('map', {
        crs: L.CRS.Simple, minZoom: -5, maxZoom: 2, 
        zoomControl: false, attributionControl: false,
        preferCanvas: true, wheelDebounceTime: 150 
    });

    const isMobile = window.innerWidth <= 768;
    const pinSize = isMobile ? [26, 26] : [28, 28];

    if (isDevMode) {
        document.getElementById('map').classList.add('dev-mode-cursor');
        document.getElementById('dev-panel').classList.add('active'); 
    }

    const bounds = [[0, 0], [currentConfig.h, currentConfig.w]];
    L.imageOverlay(currentConfig.img, bounds).addTo(map);

    const zoomSettings = { pc: -1.5, mobile: -2.5 };
    const targetZoom = isMobile ? zoomSettings.mobile : zoomSettings.pc;
    map.setView([currentConfig.h / 2, currentConfig.w / 2], targetZoom);

    // 맵 선택 셀렉트 박스
    const mapSelect = document.getElementById('main-map-select');
    for (const [key, val] of Object.entries(mapsDB)) {
        const option = document.createElement('option');
        option.value = key; option.innerText = val.name;
        if (key === currentMapId) option.selected = true;
        mapSelect.appendChild(option);
    }
    mapSelect.onchange = function() {
        const nextId = this.value + (isDevMode ? '_dev' : '');
        window.location.search = `?id=${nextId}`;
    };

    // 전역 변수
    let pathData = {};
    let currentPathLayer = null;
    let layerGroups = {}; 
    let allMarkers = []; 
    let cachedData = null; 
    let isClusterOn = localStorage.getItem('clusterMode') !== 'false'; 
    let currentPathIds = []; 
    let activePathMarkersMap = {}; 
    let globalMarkerCache = {}; // 모든 맵의 마커 정보를 담을 전역 캐시
    
    // Dev Mode 변수
    let devRecording = false;
    let devPathList = [];

    // ★ [데이터 로드] 모든 맵 데이터 한꺼번에 읽기 (Promise.all)
    document.addEventListener('DOMContentLoaded', () => {
        const targetPath = urlParams.get('path');
        
        // mapsDB에 있는 모든 JSON 로드
        const fetchPromises = Object.keys(mapsDB).map(key => {
            return fetch(mapsDB[key].json)
                .then(res => {
                    if (!res.ok) throw new Error(`Failed to load ${key}`);
                    return res.json();
                })
                .then(data => ({ key, data }));
        });

        Promise.all(fetchPromises)
            .then(results => {
                // 결과를 globalMarkerCache에 통합 저장
                results.forEach(({ key, data }) => {
                    data.forEach(item => {
                        // 각 마커에 소속 map 정보를 추가하여 저장
                        globalMarkerCache[item.id] = { ...item, map: key };
                    });

                    // 현재 보여줄 맵 데이터 저장
                    if (key === currentMapId) {
                        cachedData = data;
                    }
                });

                // 현재 맵 렌더링
                if (cachedData) {
                    createMarkers(cachedData);
                    generateSidebar(cachedData);
                } else {
                    console.error("현재 맵 데이터를 찾을 수 없습니다.");
                }

                // ★★★ [수정됨] URL에 marker 파라미터가 있으면 해당 위치로 점프 ★★★
            const targetMarkerId = urlParams.get('marker');
            // 경로 모드가 아닐 때만 여기서 바로 점프 (경로 모드는 activatePath에서 처리)
            if (targetMarkerId && !targetPath) {
                const targetItem = allMarkers.find(m => m.id == targetMarkerId);
                if (targetItem) {
                    // 클러스터 모드인지 확인하여 처리
                    const group = layerGroups[targetItem.type];
                    if (isClusterOn && group && group.zoomToShowLayer) {
                        // 클러스터 내부에 숨어있다면 펼치면서 이동
                        group.zoomToShowLayer(targetItem.marker, function() {
                            targetItem.marker.openPopup();
                        });
                    } else {
                        // 클러스터가 아니면 바로 이동 (줌 레벨 0)
                        map.flyTo(targetItem.marker.getLatLng(), 0, { animate: true, duration: 1.0 });
                        map.once('moveend', function() {
                            targetItem.marker.openPopup();
                        });
                    }
                }
            }
            // ★★★ 수정 끝 ★★★

            loadPathData(false, targetPath);
            })
            .catch(err => { 
                console.warn("데이터 로드 실패, 샘플 데이터 사용:", err);
                cachedData = sampleData;
                // 샘플 데이터도 전역 캐시에 등록
                sampleData.forEach(item => globalMarkerCache[item.id] = { ...item, map: currentMapId });
                
                createMarkers(sampleData);
                generateSidebar(sampleData);
                loadPathData(true); 
            });
    });

    // Dev Mode 기능
    window.toggleDevRecording = function() {
        devRecording = !devRecording;
        const btn = document.getElementById('dev-record-btn');
        if(devRecording) {
            btn.classList.add('recording');
            btn.innerHTML = "🔴 REC ON";
        } else {
            btn.classList.remove('recording');
            btn.innerHTML = "⚫ REC";
        }
    };

    window.copyDevPath = function() {
        if(devPathList.length === 0) { alert("추가된 마커가 없습니다."); return; }
        const jsonStr = JSON.stringify(devPathList, null, 2);
        navigator.clipboard.writeText(jsonStr).then(() => {
            alert("경로 데이터가 복사되었습니다! path.json에 붙여넣으세요.");
        });
    };

    // 저장/로드 메뉴 토글
    window.toggleSaveLoadMenu = function() {
        const menu = document.getElementById('save-load-menu');
        if (menu) menu.classList.toggle('active');
    };

    document.addEventListener('click', function(e) {
        const menu = document.getElementById('save-load-menu');
        const btn = document.querySelector('.bottom-left-controls .glass-box');
        if (menu && menu.classList.contains('active')) {
            if (!menu.contains(e.target) && !btn.contains(e.target)) {
                menu.classList.remove('active');
            }
        }
    });

    // 경로 데이터 로드 함수
    function loadPathData(useSample = false, autoStartPath = null) {
        if (useSample) {
            renderPathList(samplePathData);
            return;
        }
        fetch('../json/path.json')
            .then(res => {
                if (!res.ok) throw new Error("Path file not found");
                return res.json();
            })
            .then(data => {
                renderPathList(data);
                if (autoStartPath && data[autoStartPath]) {
                    activatePath(autoStartPath);
                }
            })
            .catch(err => {
                console.log("Path load failed, using sample:", err);
                renderPathList(samplePathData);
            });
    }

        function renderPathList(data) {
        pathData = data;
        const container = document.getElementById('path-list-dynamic');
        if(!container) return;
        container.innerHTML = '';
        
        // 1. 데이터 그룹화 (카테고리별로 묶기)
        const groups = {};
        
        for (const [key, info] of Object.entries(pathData)) {
            // category 필드가 있으면 사용, 없으면 '지역탐험'으로 분류
            const catName = info.category ? info.category : '지역탐험';
            
            if (!groups[catName]) {
                groups[catName] = [];
            }
            groups[catName].push({ key, ...info });
        }

        // 2. 그룹별로 렌더링
        // (원하는 순서가 있다면 여기서 keys를 정렬하면 됩니다. 지금은 발견된 순서대로)
        for (const [category, items] of Object.entries(groups)) {
            
            // (1) 카테고리 헤더 생성
            const header = document.createElement('div');
            header.className = 'path-category-header';
            header.innerText = category;
            container.appendChild(header);

            // (2) 해당 카테고리의 그리드 컨테이너 생성
            const gridDiv = document.createElement('div');
            gridDiv.className = 'path-category-grid';

            // (3) 아이템들 추가
            items.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'path-item';
                itemDiv.onclick = () => activatePath(item.key);
                
                itemDiv.innerHTML = `
                    <svg class="path-icon" viewBox="0 0 24 24">
                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                    </svg>
                    <div class="path-name">${item.title}</div>
                `;
                gridDiv.appendChild(itemDiv);
            });

            container.appendChild(gridDiv);
        }
    }

    window.handlePathButtonClick = function() {
        if (currentPathLayer) {
            clearPath();
        } else {
            const pathPanel = document.getElementById('path-panel');
            if (pathPanel.classList.contains('active')) {
                closeAllPanels();
            } else {
                togglePanel('path');
            }
        }
    };

   // [수정] 경로 활성화 함수 (평면 좌표 정렬 기능 포함)
  // [수정] 경로 활성화 함수 (지상 우선 + 거리순 정렬)
 // [수정] 경로 활성화 함수 (완료 순서 동기화 + 맵 점프 기능 복구)
    function activatePath(pathKey) {
        clearPath();
        const routeData = pathData[pathKey];
        if (!routeData || !routeData.markers) return;
        
        // 원본 데이터 가져오기
        const originalRouteIds = routeData.markers;
        activePathMarkersMap = {}; 

        // -----------------------------------------------------------
        // 1. [데이터 분리] 현재 맵 마커 vs 다른 맵 마커
        // -----------------------------------------------------------
        let localMarkerItems = []; // 현재 맵에 찍을 마커 객체들 (정렬 대상)
        let otherMapEntries = [];  // 다른 맵에 있는 데이터들 (순서 유지)

        originalRouteIds.forEach(entry => {
            let mId, mMap;
            // ID/Map 정보 추출
            if (typeof entry === 'object') {
                mId = entry.id; mMap = entry.map;
            } else {
                mId = entry;
                // 전역 캐시 확인
                const cached = globalMarkerCache[mId] || globalMarkerCache[Number(mId)] || globalMarkerCache[String(mId)];
                mMap = cached ? cached.map : currentMapId; // 정보 없으면 현재 맵으로 가정
            }

            if (mMap === currentMapId) {
                // 현재 맵 마커라면: 정렬을 위해 마커 객체(x,y 포함)를 찾아서 넣음
                const item = allMarkers.find(m => m.id == mId);
                if (item) localMarkerItems.push(item);
            } else {
                // 다른 맵 마커라면: 나중에 뒤에 붙이기 위해 따로 보관
                otherMapEntries.push(typeof entry === 'object' ? entry : { id: mId, map: mMap });
            }
        });

        // -----------------------------------------------------------
        // 2. [정렬 로직] 지상 우선 + 거리순 정렬 (TSP)
        // -----------------------------------------------------------
        function solveTSP(list, startPoint) {
            if (list.length === 0) return [];
            let sorted = [];
            let remaining = [...list];
            
            // 시작점 결정 (기준점과 가장 가까운 것부터)
            if (startPoint) {
                let nearestIndex = -1;
                let minDist = Infinity;
                remaining.forEach((item, index) => {
                    const p2 = item.marker.getLatLng();
                    const dist = (startPoint.lng - p2.lng)**2 + (startPoint.lat - p2.lat)**2;
                    if (dist < minDist) { minDist = dist; nearestIndex = index; }
                });
                if (nearestIndex !== -1) {
                    sorted.push(remaining[nearestIndex]);
                    remaining.splice(nearestIndex, 1);
                }
            } else {
                sorted.push(remaining[0]);
                remaining.splice(0, 1);
            }

            // 나머지 연결
            while (remaining.length > 0) {
                const current = sorted[sorted.length - 1];
                const p1 = current.marker.getLatLng();
                let nearestIndex = -1;
                let minDist = Infinity;
                
                remaining.forEach((item, index) => {
                    const p2 = item.marker.getLatLng();
                    const dist = (p1.lng - p2.lng)**2 + (p1.lat - p2.lat)**2;
                    if (dist < minDist) { minDist = dist; nearestIndex = index; }
                });

                if (nearestIndex !== -1) {
                    sorted.push(remaining[nearestIndex]);
                    remaining.splice(nearestIndex, 1);
                } else {
                    sorted.push(...remaining);
                    break;
                }
            }
            return sorted;
        }

        // 정렬 실행
        let sortedLocalItems = [];
        if (localMarkerItems.length > 0) {
            const normalItems = localMarkerItems.filter(i => !i.name.includes('(지하)'));
            const undergroundItems = localMarkerItems.filter(i => i.name.includes('(지하)'));

            const sortedNormal = solveTSP(normalItems, null);
            
            let lastPoint = null;
            if (sortedNormal.length > 0) {
                lastPoint = sortedNormal[sortedNormal.length - 1].marker.getLatLng();
            }
            const sortedUnderground = solveTSP(undergroundItems, lastPoint);
            
            sortedLocalItems = [...sortedNormal, ...sortedUnderground];
        }

        // -----------------------------------------------------------
        // 3. [핵심 수정] 실제 이동 경로 데이터(currentPathIds) 재구성
        //    (정렬된 현재 맵 마커 + 다른 맵 마커)
        // -----------------------------------------------------------
        const sortedLocalEntries = sortedLocalItems.map(item => ({ id: item.id, map: currentMapId }));
        
        // ★★★ 이 부분이 중요! 완료 시 이동할 순서를 정렬된 순서로 덮어씌웁니다. ★★★
        currentPathIds = [...sortedLocalEntries, ...otherMapEntries];

        // 만약 현재 맵에 표시할 게 하나도 없으면 이동 (기존 로직)
        if (sortedLocalItems.length === 0 && otherMapEntries.length > 0) {
            const nextTarget = otherMapEntries[0];
            localStorage.setItem('activePathKey', pathKey);
            window.location.href = `?id=${nextTarget.map}&marker=${nextTarget.id}&path=${pathKey}`;
            return;
        }

        // -----------------------------------------------------------
        // 4. [그리기] 마커 및 선 렌더링
        // -----------------------------------------------------------
        const storageKey = `completed_${currentMapId}`;
        const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];

        // 기존 레이어 정리
        for (const key in layerGroups) { map.removeLayer(layerGroups[key]); }
        const filterGroup = document.querySelector('.bottom-right-controls .glass-group');
        if (filterGroup) filterGroup.style.display = 'none';

        currentPathLayer = L.featureGroup();
        const latlngs = [];

        sortedLocalItems.forEach((item, index) => {
            const latlng = item.marker.getLatLng();
            latlngs.push(latlng);
            
            const itemIconPath = `../images/${typeMapping[item.type] || 'logo'}.png`;
            const isCompleted = completedList.includes(item.id);
            const completedClass = isCompleted ? 'marker-completed' : '';
            
            // ★ [점프 복구] 현재 맵의 마지막 마커이면서, 다음에 갈 맵이 남아있다면 Gateway 표시
            let isGateway = false;
            if (index === sortedLocalItems.length - 1 && otherMapEntries.length > 0) {
                isGateway = true;
            }
            
            const gatewayClass = isGateway ? 'gateway-marker' : '';
            let badgeContent = index + 1;
            
            // 게이트웨이 아이콘 (화살표)
            if (isGateway) {
                badgeContent = `<svg viewBox="0 0 24 24" style="width:12px;height:12px;fill:black;"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>`;
            }

            const pathIcon = L.divIcon({
                className: `custom-div-icon ${completedClass} ${gatewayClass}`,
                html: `<div class="path-marker-box">
                           <img src="${itemIconPath}" class="path-marker-icon" onerror="this.src='../images/stone.png'">
                           <div class="path-order-badge">${badgeContent}</div>
                       </div>`,
                iconSize: [34, 34], iconAnchor: [17, 17], popupAnchor: [0, -20]
            });

            const markerClone = L.marker(latlng, { icon: pathIcon })
                .bindPopup(item.marker.getPopup().getContent());
            
            currentPathLayer.addLayer(markerClone);
            activePathMarkersMap[item.id] = markerClone; 
        });

        // 선 그리기
        if (latlngs.length > 1) {
            const polyline = L.polyline(latlngs, {
                color: '#a08040', weight: 4, opacity: 0.9, dashArray: '5, 10', lineJoin: 'round'
            });
            currentPathLayer.addLayer(polyline);
        }

        currentPathLayer.addTo(map);
        document.getElementById('path-toggle-btn').classList.add('path-active');

        // 5. 시작점 이동 (URL 파라미터 or 정렬된 첫 번째)
        const targetMarkerId = new URLSearchParams(window.location.search).get('marker');
        let jumpTarget = latlngs.length > 0 ? latlngs[0] : null;
        let targetMarkerObj = null;

        if (targetMarkerId && activePathMarkersMap[targetMarkerId]) {
            targetMarkerObj = activePathMarkersMap[targetMarkerId];
            jumpTarget = targetMarkerObj.getLatLng();
        }

        if (jumpTarget) {
            map.flyTo(jumpTarget, 0, { animate: true, duration: 1.5 });
            if (targetMarkerObj) {
                map.once('moveend', () => targetMarkerObj.openPopup());
            }
        }
        
        localStorage.setItem('activePathKey', pathKey);
        updatePathSummaryUI(); 
        closeAllPanels();
    }
    function isGateway(index, routeIds) {
        if (index >= routeIds.length - 1) return false;
        const currentEntry = routeIds[index];
        const nextEntry = routeIds[index + 1];
        
        // 현재 마커의 맵
        let currentMap = (typeof currentEntry === 'object') ? currentEntry.map : (globalMarkerCache[currentEntry]?.map || currentMapId);
        
        // 다음 마커의 맵
        let nextMap = (typeof nextEntry === 'object') ? nextEntry.map : (globalMarkerCache[nextEntry]?.map || currentMapId);

        return currentMap === currentMapId && nextMap !== currentMapId;
    }

    // 경로 종료 및 UI 복원
    function clearPath() {
        if (currentPathLayer) {
            map.removeLayer(currentPathLayer);
            currentPathLayer = null;
            currentPathIds = [];
            activePathMarkersMap = {};
            localStorage.removeItem('activePathKey');
        }
        document.getElementById('path-toggle-btn').classList.remove('path-active');

        // 요약 바 숨기기
        const summaryBar = document.getElementById('path-summary-bar');
        if(summaryBar) summaryBar.style.display = 'none';

        // 필터 버튼 다시 보이기
        const filterGroup = document.querySelector('.bottom-right-controls .glass-group');
        if(filterGroup) filterGroup.style.display = 'flex';

        // 기존 필터 상태 복원
        const savedFilters = JSON.parse(localStorage.getItem('map_filter_settings')) || {};
        for (const key in layerGroups) {
            const shouldShow = (savedFilters[key] !== undefined) ? savedFilters[key] : true;
            if (shouldShow) { layerGroups[key].addTo(map); }
        }
    }

    function togglePanel(type) {
        const searchPanel = document.getElementById('search-panel');
        const filterPanel = document.getElementById('filter-panel');
        const pathPanel = document.getElementById('path-panel');
        
        searchPanel.classList.remove('active');
        filterPanel.classList.remove('active');
        pathPanel.classList.remove('active');
        
        if (type === 'path') {
            pathPanel.classList.add('active');
        } else if (type === 'search') {
            searchPanel.classList.add('active');
            document.getElementById('marker-search').focus();
        } else if (type === 'filter') {
            filterPanel.classList.add('active');
        }
    }

    function closeAllPanels() {
        document.getElementById('search-panel').classList.remove('active');
        document.getElementById('filter-panel').classList.remove('active');
        document.getElementById('path-panel').classList.remove('active');
    }

    // 마커 생성 함수
    function createMarkers(data) {
        const storageKey = `completed_${currentMapId}`;
        const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];
        const savedFilters = JSON.parse(localStorage.getItem('map_filter_settings')) || {};
        
        allMarkers = []; layerGroups = {}; 
        const markersByType = {}; 

        try {
            data.forEach(item => {
                // 타입별 배열 초기화
                if (!markersByType[item.type]) { markersByType[item.type] = []; }
                
                const isCompleted = completedList.includes(item.id);
                const imgName = typeMapping[item.type] || "stone"; 
                const iconPath = `../images/${imgName}.png`;
                const pinColor = colorMapping[item.type] || "#555";

      // 기존 pinIcon 정의 부분을 아래 코드로 교체하세요.
// createMarkers 함수 내부의 pinIcon 정의를 이걸로 덮어쓰세요.

/* 찾을 위치: createMarkers 함수 내부
   수정 내용: style 속성을 바깥쪽 div(.pin-marker)로 이동
*/

// [수정] 일반 핀 아이콘 정의 (색상 정보를 부모 div로 이동 + 앵커 수정)
                const pinIcon = L.divIcon({
                    className: isCompleted ? 'marker-completed' : '',
                    // ★ 핵심 변경: style="--pin-color..."를 바깥쪽 div(.pin-marker)로 옮겼습니다.
                    html: `<div class="pin-marker" style="--pin-color: ${pinColor};">
                               <div class="pin-inner-circle">
                                   <img src="${iconPath}" onerror="this.src='../images/stone.png'">
                               </div>
                           </div>`,
                    
                    // 모양이 원형으로 바뀌므로 중심점(Anchor)도 정중앙으로 맞춰야 합니다.
                    iconSize: pinSize, 
                    iconAnchor: [pinSize[0] / 2, pinSize[1] / 2], 
                    popupAnchor: [0, -(pinSize[1] / 2 + 5)]
                });
                const marker = L.marker([item.y, item.x], { icon: pinIcon });
                
               // Dev Mode 클릭 이벤트 (녹화 및 상태 표시)
                // Dev Mode 클릭 이벤트 (타입별 전체 집계 기능)
                marker.on('click', () => {
                    if (devRecording) {
                        const existingIndex = devPathList.findIndex(entry => entry.id === item.id && entry.map === currentMapId);
                        
                        // 1. 리스트 추가/제거
                        if (existingIndex > -1) {
                            devPathList.splice(existingIndex, 1);
                            L.DomUtil.removeClass(marker._icon, 'dev-selected');
                        } else {
                            devPathList.push({ id: item.id, map: currentMapId });
                            L.DomUtil.addClass(marker._icon, 'dev-selected');
                        }
                        
                        // 2. 전체 개수 업데이트
                        document.getElementById('dev-count').innerText = devPathList.length;

                        // ★ 3. [핵심] 현재 담긴 모든 마커의 타입별 개수 계산
                        const typeCounts = {};
                        
                        devPathList.forEach(entry => {
                            // 마커 정보 찾기 (전역 캐시 우선, 없으면 현재 맵 리스트)
                            let targetInfo = globalMarkerCache[entry.id];
                            if (!targetInfo) {
                                targetInfo = allMarkers.find(m => m.id == entry.id);
                            }
                            
                            // 타입 카운팅
                            if (targetInfo && targetInfo.type) {
                                typeCounts[targetInfo.type] = (typeCounts[targetInfo.type] || 0) + 1;
                            }
                        });

                        // 4. 화면에 요약해서 보여주기
                        const statusBox = document.getElementById('dev-status');
                        if (statusBox) {
                            // "타입 갯수" 문자열 생성 (예: 상자 2 | 보스 1)
                            const summaryHtml = Object.entries(typeCounts)
                                .map(([type, count]) => 
                                    `<span><span class="dev-type-tag">${type}</span> <span class="dev-type-count">${count}</span></span>`
                                )
                                .join('<span style="color:#555; margin:0 6px;">|</span>'); // 구분자

                            if (summaryHtml) {
                                statusBox.innerHTML = summaryHtml;
                                statusBox.style.display = 'flex';
                            } else {
                                statusBox.style.display = 'none';
                            }
                        }
                    } 
                    // 일반 모드 팝업
                });

                marker.bindPopup(() => generatePopupContent(item, storageKey));
                markersByType[item.type].push(marker);
                allMarkers.push({ id: item.id, name: item.name, desc: item.desc || "", type: item.type, marker: marker });
            });

            // 클러스터 또는 일반 레이어 그룹 생성
            for (const type in markersByType) {
                const markersArray = markersByType[type];
                if (isClusterOn) {
                    const typeColor = colorMapping[type] || "#555";
                    if (!layerGroups[type]) {
                        layerGroups[type] = L.markerClusterGroup({
                            disableClusteringAtZoom: 0, spiderfyOnMaxZoom: true, showCoverageOnHover: false, 
                            chunkedLoading: true, chunkInterval: 200,   
                            animate: false, animateAddingMarkers: false, maxClusterRadius: 80,      
                            iconCreateFunction: function(cluster) {
                                const count = cluster.getChildCount();
                                const countText = count > 99 ? '99+' : count;
                                                                // 배경색 대신 CSS 변수로 색상 정보만 전달
                                const html = `
                                    <div class="simple-cluster-marker" style="--cluster-color: ${typeColor};">
                                        ${countText}
                                    </div>`;

                                return L.divIcon({
                                    html: html, className: '', iconSize: [30, 30], iconAnchor: [15, 15]
                                });
                            }
                        });
                    }
                    layerGroups[type].addLayers(markersArray);
                } else {
                    if (!layerGroups[type]) { layerGroups[type] = L.layerGroup(); }
                    markersArray.forEach(m => layerGroups[type].addLayer(m));
                }
            }

            // 필터 상태 반영
            for (const key in layerGroups) {
                const shouldShow = (savedFilters[key] !== undefined) ? savedFilters[key] : true;
                if (shouldShow) { layerGroups[key].addTo(map); }
            }
        } catch (e) { console.error("Marker creation error:", e); }
    }

    // 사이드바 필터 생성
    function generateSidebar(data) {
        const filterList = document.getElementById('filter-list');
        if(!filterList) return;
        filterList.innerHTML = '';
        
        const savedFilters = JSON.parse(localStorage.getItem('map_filter_settings')) || {};

        try {
            const counts = {};
            data.forEach(item => counts[item.type] = (counts[item.type] || 0) + 1);

            for (const [type, count] of Object.entries(counts)) {
                const div = document.createElement('div');
                const isActive = layerGroups[type] && map.hasLayer(layerGroups[type]);
                
                div.className = `filter-item ${isActive ? 'active' : 'inactive'}`;
                const imgName = typeMapping[type] || "stone";
                div.innerHTML = `
                    <div class="filter-left-group">
                        <img src="../images/${imgName}.png" class="filter-icon-img" onerror="this.style.display='none'">
                        <span class="filter-text-name">${type}</span>
                    </div>
                    <span class="filter-count">${count}</span>`;
                div.onclick = function() {
                    const isNowActive = div.classList.contains('active');
                    if (isNowActive) {
                        div.classList.remove('active'); div.classList.add('inactive');
                        toggleLayer(type, false);
                    } else {
                        div.classList.remove('inactive'); div.classList.add('active');
                        toggleLayer(type, true);
                    }
                    saveFilterState();
                };
                filterList.appendChild(div);
            }
        } catch (e) { console.error("Sidebar generation error:", e); }
    }

    function saveFilterState() {
        const status = {};
        for (const key in layerGroups) { 
            status[key] = map.hasLayer(layerGroups[key]); 
        }
        localStorage.setItem('map_filter_settings', JSON.stringify(status));
    }

    function toggleLayer(type, isChecked) {
        if (isChecked) { if (layerGroups[type]) map.addLayer(layerGroups[type]); } 
        else { if (layerGroups[type]) map.removeLayer(layerGroups[type]); }
    }

    function setAllFilters(status) {
        const items = document.querySelectorAll('.filter-item');
        items.forEach(div => {
            const typeName = div.querySelector('.filter-text-name').innerText;
            if (status) {
                div.classList.remove('inactive'); div.classList.add('active');
                toggleLayer(typeName, true);
            } else {
                div.classList.remove('active'); div.classList.add('inactive');
                toggleLayer(typeName, false);
            }
        });
        saveFilterState();
    }

    // 검색 기능
    const searchInput = document.getElementById('marker-search');
    const searchResultList = document.getElementById('search-result-list');

    searchInput.addEventListener('input', function(e) {
        const keyword = e.target.value.trim().toLowerCase();
        searchResultList.innerHTML = '';
        if (keyword === "") {
            searchResultList.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">검색어를 입력하세요.</div>';
            return;
        }
        const results = allMarkers.filter(item => item.name.toLowerCase().includes(keyword) || item.desc.toLowerCase().includes(keyword));
        if (results.length === 0) { 
            searchResultList.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">검색 결과가 없습니다.</div>'; 
            return; 
        }
        results.forEach(item => {
            const row = document.createElement('div'); row.className = 'search-result-row';
            const imgName = typeMapping[item.type] || "stone";
            row.innerHTML = `<div class="result-info"><div class="result-name">${item.name}</div><div class="result-desc">${item.desc}</div></div><img src="../images/${imgName}.png" class="result-type-icon" onerror="this.style.display='none'">`;
            
            row.onclick = () => {
                if (!map.hasLayer(layerGroups[item.type])) map.addLayer(layerGroups[item.type]);
                const jumpZoom = Math.min(map.getZoom() + 3, 1); 
                map.flyTo(item.marker.getLatLng(), jumpZoom, { animate: true, duration: 1.5 });
                
                map.once('moveend', function() { item.marker.openPopup(); });
                if (window.innerWidth <= 480) closeAllPanels();
            };
            searchResultList.appendChild(row);
        });
    });

    // 팝업 내용 생성
        // 팝업 내용 생성 (Dev 모드 ID 복사 버튼 추가됨)
    function generatePopupContent(item, storageKey) {
        const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];
        const isCompleted = completedList.includes(item.id);
        
        let html = `<div class="popup-inner">`;
        
        // ★ [Dev 모드 전용] ID 복사 버튼 추가
        if (typeof isDevMode !== 'undefined' && isDevMode) {
            html += `<div onclick="copyToClipboard('${item.id}'); alert('ID ${item.id} 복사 완료!');" 
                          style="cursor:pointer; margin-bottom:10px; padding:6px; background:rgba(0, 229, 255, 0.1); border:1px solid #00e5ff; color:#00e5ff; border-radius:6px; font-size:12px; font-weight:bold; display:flex; align-items:center; justify-content:center; gap:5px;">
                          🛠 ID 복사: ${item.id}
                     </div>`;
        }

        html += `<span class="popup-title">${item.name}</span><div class="popup-type-badge">${item.type}</div>`;
        
        if (item.image) {
            const ytId = getYouTubeId(item.image);
            if (ytId) {
                html += `<div class="popup-youtube-container"><iframe src="https://www.youtube.com/embed/${ytId}" frameborder="0" allowfullscreen></iframe></div>`;
            } else {
                html += `<img src="${item.image}" class="popup-img" alt="${item.name}">`;
            }
        }
        if (item.desc) html += `<div class="popup-desc">${item.desc}</div>`;
        
        html += `<div class="btn-container"><button onclick="shareMarker(${item.id})" class="action-btn btn-wiki">🔗 공유</button>`;
        if (item.link) { html += `<a href="${item.link}" target="_blank" class="action-btn btn-wiki">📖 공략</a>`; }
        
        const btnText = isCompleted ? "취소" : "완료";
        const btnClass = isCompleted ? "btn-undo" : "btn-complete";
        html += `<button onclick="toggleComplete(${item.id}, '${storageKey}')" class="action-btn ${btnClass}">${btnText}</button></div></div>`;
        return html;
    }

    // 완료 처리 토글
    window.toggleComplete = function(id, storageKey) {
        let list = JSON.parse(localStorage.getItem(storageKey)) || [];
        const index = list.indexOf(id); 
        
        // 지도상의 마커 찾기 (일반 마커 혹은 경로 모드 마커)
        let targetMarkerObj = allMarkers.find(m => m.id === id);
        let marker = targetMarkerObj ? targetMarkerObj.marker : null;
        
        if (currentPathLayer && activePathMarkersMap[id]) {
            marker = activePathMarkersMap[id];
        }

        const isNowComplete = (index === -1);
        if (isNowComplete) { list.push(id); } else { list.splice(index, 1); }
        localStorage.setItem(storageKey, JSON.stringify(list)); 
        
        // UI 업데이트
        updatePathSummaryUI();
        
        if (marker) {
            if (isNowComplete) { L.DomUtil.addClass(marker._icon, 'marker-completed'); }
            else { L.DomUtil.removeClass(marker._icon, 'marker-completed'); }
            
            // 팝업 갱신 (완료/취소 버튼 텍스트 변경을 위해)
            marker.closePopup(); 
            marker.openPopup();
        }

        // 경로 모드일 때 자동 이동
        if (isNowComplete && currentPathIds.length > 0) {
            const currentEntry = currentPathIds.find(entry => (typeof entry === 'object' ? entry.id : entry) == id);
            const pathIndex = currentPathIds.indexOf(currentEntry);
            
            if (pathIndex !== -1 && pathIndex < currentPathIds.length - 1) {
                const nextEntry = currentPathIds[pathIndex + 1];
                const nextId = (typeof nextEntry === 'object') ? nextEntry.id : nextEntry;
                const nextMap = (typeof nextEntry === 'object') ? nextEntry.map : currentMapId;
                
                if (nextMap === currentMapId) {
                    const nextMarker = activePathMarkersMap[nextId];
                    if (nextMarker) {
                        setTimeout(() => {
                            map.flyTo(nextMarker.getLatLng(), 0, { animate: true, duration: 1.0 });
                            map.once('moveend', () => nextMarker.openPopup());
                        }, 500);
                    }
                } else {
                    setTimeout(() => {
                        const currentPathKey = localStorage.getItem('activePathKey') || '';
                        window.location.href = `?id=${nextMap}&marker=${nextId}&path=${currentPathKey}`;
                    }, 500);
                }
            }
        }
    };

    window.shareMarker = function(id) {
        const url = new URL(window.location.href);
        url.searchParams.set('marker', id);
        url.searchParams.delete('path'); 
        copyToClipboard(url.toString());
    };

    function getYouTubeId(url) {
        if (!url) return null;
        const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[2].length === 11) ? match[2] : null;
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.log(err); }); } 
        else { if (document.exitFullscreen) { document.exitFullscreen(); } }
    }

    window.toggleClusterMode = function() {
        isClusterOn = !isClusterOn;
        localStorage.setItem('clusterMode', isClusterOn);
        for (const key in layerGroups) map.removeLayer(layerGroups[key]);
        layerGroups = {}; allMarkers = [];
        if (cachedData) { createMarkers(cachedData); generateSidebar(cachedData); }
    };

    function exportCompletedPins() {
        try {
            if (!currentMapId) { alert("맵 ID를 찾을 수 없습니다."); return; }
            const storageKey = `completed_${currentMapId}`;
            const data = localStorage.getItem(storageKey);
            if (!data || data === "[]") { alert("저장할 완료 기록이 없습니다."); return; }
            const blob = new Blob([data], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = `completed_markers_${currentMapId}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (err) { alert("오류 발생: " + err.message); }
    }

    function importCompletedPins(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const json = JSON.parse(e.target.result);
                if (!Array.isArray(json)) throw new Error("Invalid format");
                if (confirm(`불러온 기록으로 현재 완료 상태를 덮어쓰시겠습니까? (${json.length}개)`)) {
                    const storageKey = `completed_${currentMapId}`;
                    localStorage.setItem(storageKey, JSON.stringify(json));
                    location.reload();
                }
            } catch (err) { alert("파일 형식이 올바르지 않습니다."); }
            input.value = ""; 
        };
        reader.readAsText(file);
    }

    window.copyToClipboard = function(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(text).catch(() => fallbackCopy(text)); }
    };

    function fallbackCopy(text) {
        const ta = document.createElement("textarea"); ta.value = text;
        ta.style.position="fixed"; ta.style.left="0"; ta.style.top="0";
        document.body.appendChild(ta); ta.focus(); ta.select();
        try { document.execCommand('copy'); } catch (err) { console.error(err); }
        document.body.removeChild(ta);
    }

    // ★ [경로 요약] 모든 맵의 진행도를 통합 계산
    function updatePathSummaryUI() {
        const container = document.getElementById('path-summary-bar');
        
        // 경로 레이어가 없으면 숨김
        if (!currentPathLayer) { 
            container.style.display = 'none'; 
            return; 
        }
        
        const summary = {};

        currentPathIds.forEach(entry => {
            // 1. ID와 Map ID 추출
            let id, mapId;
            if (typeof entry === 'object') {
                id = entry.id;
                mapId = entry.map;
            } else {
                id = entry;
                // 객체가 아닌 경우, 캐시에서 맵 정보를 찾음. 없으면 현재 맵으로 가정
                const cachedItem = globalMarkerCache[id];
                mapId = cachedItem ? cachedItem.map : currentMapId;
            }

            // 2. 전역 캐시에서 아이템 정보 조회
            const item = globalMarkerCache[id];
            
            if (item) {
                // 3. 해당 마커가 속한 맵의 완료 기록을 가져옴
                const storageKey = `completed_${mapId}`;
                const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];

                if (!summary[item.type]) {
                    summary[item.type] = { total: 0, done: 0 };
                }
                summary[item.type].total++;
                
                // 4. 완료 여부 체크
                if (completedList.includes(id)) {
                    summary[item.type].done++;
                }
            }
        });

        // HTML 생성
        const htmlChunks = Object.entries(summary).map(([type, d]) => 
            `<div class="summary-chunk">${type} <b>(${d.done}/${d.total})</b></div>`
        );

        if (htmlChunks.length === 0) {
            container.style.display = 'none';
        } else {
            container.innerHTML = htmlChunks.join('');
            container.style.display = 'flex';
        }
    }
</script>

   </body>
</html>
