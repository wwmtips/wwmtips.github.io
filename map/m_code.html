<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>ì—°ìš´ í•œêµ­ì–´ ë§µ for Wiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>


    <link rel="icon" type="image/png" sizes="32x32" href="../fav/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../fav/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="57x57" href="../fav/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../fav/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../fav/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../fav/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../fav/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../fav/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="../fav/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="../fav/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../fav/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="../fav/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../fav/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../fav/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../fav/favicon-16x16.png">
    <link rel="manifest" href="../fav/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="fav/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="map_style.css">

</head>

<body>

    <div class="top-left-controls">
        <select id="main-map-select" class="glass-select"></select>
    </div>

    <div id="dev-panel" class="dev-controls">
        <div class="dev-btn" id="dev-record-btn" onclick="toggleDevRecording()">âš« REC</div>
        <div class="dev-btn" onclick="copyDevPath()">ğŸ“‹ JSON (<span id="dev-count">0</span>)</div>

        <div id="dev-status" class="dev-status-box"></div>
    </div>

    <div class="top-right-controls">
        <div class="glass-box" onclick="togglePanel('search')" title="ê²€ìƒ‰">
            <svg class="icon-svg" viewBox="0 0 24 24">
                <path
                    d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
            </svg>
        </div>
    </div>

    <div class="bottom-left-controls">
        <div id="save-load-menu" class="save-load-popup">
            <div class="popup-item" onclick="exportCompletedPins(); toggleSaveLoadMenu();">
                <svg viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
                </svg>
                <span>ì €ì¥í•˜ê¸°</span>
            </div>
            <div class="popup-item" onclick="document.getElementById('import-file').click(); toggleSaveLoadMenu();">
                <svg viewBox="0 0 24 24">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z" />
                </svg>
                <span>ë¶ˆëŸ¬ì˜¤ê¸°</span>
            </div>
        </div>
        <div class="glass-box" onclick="toggleSaveLoadMenu()" title="ì €ì¥ ê´€ë¦¬">
            <svg class="icon-svg" viewBox="0 0 24 24">
                <path
                    d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z" />
            </svg>
        </div>
    </div>
    <input type="file" id="import-file" style="display:none" accept=".json" onchange="importCompletedPins(this)">

    <div class="bottom-center-controls">
        <div id="path-summary-bar"></div>
        <div id="path-toggle-btn" class="glass-box" onclick="handlePathButtonClick()" title="ì¶”ì²œ ê²½ë¡œ">
            <svg class="icon-svg" viewBox="0 0 24 24">
                <path
                    d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" />
            </svg>
            <span>ê²½ë¡œ ëª¨ë“œ</span>
        </div>
    </div>

    <div class="bottom-right-controls">
        <div class="glass-group">
            <div class="glass-group-btn" onclick="toggleClusterMode()" title="ëª¨ì•„ë³´ê¸° í† ê¸€">
                <svg class="icon-svg" viewBox="0 0 24 24">
                    <path
                        d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" />
                </svg>
            </div>
            <div class="glass-group-btn" onclick="togglePanel('filter')" title="í•„í„°">
                <svg class="icon-svg" viewBox="0 0 24 24">
                    <path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z" />
                </svg>
            </div>
        </div>
        <div class="glass-single-btn" onclick="toggleFullscreen()" title="ì „ì²´ í™”ë©´">
            <svg class="icon-svg" viewBox="0 0 24 24">
                <path
                    d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6z" />
            </svg>
        </div>
    </div>

    <div id="search-panel" class="search-panel">
        <div class="panel-close-btn" onclick="closeAllPanels()">âœ•</div>
        <div class="search-wrapper">
            <input type="text" id="marker-search" class="sidebar-search-input" placeholder="ë§ˆì»¤ ì´ë¦„ ê²€ìƒ‰..."
                autocomplete="off">
            <span class="search-icon">ğŸ”</span>
        </div>
        <div id="search-result-list" class="search-results-container"></div>
    </div>

    <div id="filter-panel" class="filter-panel">
        <div class="panel-header filter-header">
            <span class="panel-title filter-title">í•„í„° ì„¤ì •</span>
            <div class="filter-controls">
                <button class="filter-control-btn" onclick="setAllFilters(true)">ì „ì²´ ì¼œê¸°</button>
                <button class="filter-control-btn" onclick="setAllFilters(false)">ì „ì²´ ë„ê¸°</button>
            </div>
            <div class="panel-close-btn" onclick="closeAllPanels()">âœ•</div>
        </div>
        <div id="filter-list" class="filter-list-container"></div>
    </div>

    <div id="path-panel" class="path-panel">
        <div class="panel-header" style="border-bottom: none; padding-bottom: 5px;">
            <span class="panel-title">ê²½ë¡œ</span>
            <div class="panel-close-btn" onclick="closeAllPanels()">âœ•</div>
        </div>

        <div class="path-list-container" id="path-list-dynamic"></div>
    </div>


    <div id="map"></div>

    <script>
        // â˜… [ì•ˆì „ ëª¨ë“œ] ìƒ˜í”Œ ë°ì´í„°
        const sampleData = [
            { id: 101, name: "ì²­í•˜ ìƒì 1", type: "ê¸°íƒ€", x: 2000, y: 3000, desc: "ë‚˜ë¬´ ì•„ë˜" },
            { id: 102, name: "ì¥êµ° ì‚¬ë‹¹ ì…êµ¬", type: "ê²½ê³„ì„", x: 2500, y: 3200, desc: "ì›Œí”„ í¬ì¸íŠ¸" },
            { id: 103, name: "ìˆ¨ê²¨ì§„ ë³´ìŠ¤", type: "ë³´ìŠ¤", x: 3000, y: 1500, desc: "ê°•ë ¥í•¨" }
        ];

        const samplePathData = {
            "sample_route": {
                "title": "ì˜ˆì‹œ ê²½ë¡œ (ìƒ˜í”Œ)",
                "desc": "ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨ ì‹œ ë³´ì—¬ì§€ëŠ” ê²½ë¡œì…ë‹ˆë‹¤.",
                "markers": [{ "id": 101, "map": "qinghe" }, { "id": 102, "map": "gesh" }]
            }, "sample_route2": {
                "title": "ì˜ˆì‹œì²­í•˜2ë¡œ (ìƒ˜í”Œ)",
                "category": "ì²­í•˜",
                "desc": "ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨ ì‹œ ë³´ì—¬ì§€ëŠ” ê²½ë¡œì…ë‹ˆë‹¤.",
                "markers": [{ "id": 101, "map": "qinghe" }, { "id": 102, "map": "gesh" }]
            }
        };

        // ë§µ ì„¤ì • ë°ì´í„°
        const mapsDB = {
            "qinghe": { name: "ì²­í•˜", img: "../map/images/qinghe.jpg", json: "../json/qinghe.json", w: 7306, h: 4732 },
            "gesh": { name: "ì¥êµ° ì‚¬ë‹¹", img: "../map/images/gesh.jpg", json: "../json/gesh.json", w: 1662, h: 1787 },
            "drs": { name: "ê¿ˆì†ì˜ ë¶ˆì„ ì„ ", img: "../map/images/dream.jpg", json: "../json/drs.json", w: 4545, h: 2743 },
            "kaifeng": { name: "ê°œë´‰", img: "../map/images/kaifeng.jpg", json: "../json/kaifeng.json", w: 5159, h: 7000 },
            "gm": { name: "ê·€ë¬¸ì‹œì¥", img: "../map/images/gm.jpg", json: "../json/gm.json", w: 5482, h: 3534 }
        };

        // íƒ€ì… ë° ìƒ‰ìƒ ë§¤í•‘
        const typeMapping = {
            "ê²½ê³„ì„": "ic_pin", "ë¬˜ë¬˜ëƒ¥": "ic_mew", "ê³ ì–‘ì´": "ic_cat",
            "ë§Œì‚¬ë¡": "ic_mansa", "ë¬˜ë¬¼": "ic_uni", "ìƒì": "ic_chest",
            "ë³´ìŠ¤": "ic_boss", "ê¸°ì—°": "ic_ki", "ì²œì§€ë¡": "ic_cj", "ì‚¬ê±´": "ic_pvp",
            "ë‚šì‹œëŒ€ê²°": "ic_fish", "íˆ¬í˜¸ëŒ€ê²°": "ic_two", "ì˜ì§€": "ic_camp", "ê°•í˜¸ì˜ë²—": "ic_pic", "ìœ ë¬¼": "ic_tr",
            "íƒë°©": "logo", "ë§Œë¬¼ì˜ìš¸ë¦¼": "ic_man", "ê³¡ê²½ì‹¬ìœ ": "ic_gk", "ê¶ìˆ ëŒ€ê²°": "logo", "ê¸°íƒ€": "logo", "ì•¼ì™¸ì œì‚¬": "logo",
            "ë¬´ìˆ ë¡œë§ºì€ì¸ì—°": "logo",
            "í’ë¥˜ì˜ì„ ë¥ ": "logo",
            "ì˜ìˆ ì¹˜ìœ ": "logo",
            "ìƒê¸°": "logo",
            "ì—½ìí¬": "logo",
            "ì±„ì§‘": "ic_fw",
            "í™”ì¥ì‹¤": "ic_tl"
        };

        const colorMapping = {
            "ìƒì": "#4CAF50", // ë°ì€ ì´ˆë¡
            "ë³´ìŠ¤": "#F44336", // ë°ì€ ë¹¨ê°•
            "ê³ ì–‘ì´": "#607D8B", // íŒŒë€ íšŒìƒ‰ (ê²€ì •ì€ ë„ˆë¬´ ì–´ë‘ì›Œì„œ ë³€ê²½)
            "ë¬˜ë¬¼": "#009688", // ë°ì€ ì²­ë¡
            "ë§Œì‚¬ë¡": "#FF9800", // ì£¼í™©
            "ê²½ê³„ì„": "#9C27B0", // ë°ì€ ë³´ë¼
            "ê¸°ì—°": "#E91E63", // ì§„í•œ ë¶„í™
            "ë¬˜ë¬˜ëƒ¥": "#673AB7", // ì§™ì€ ë³´ë¼
            "ì²œì§€ë¡": "#2196F3", // ë°ì€ íŒŒë‘
            "ì‚¬ê±´": "#3F51B5",
            "ë‚šì‹œëŒ€ê²°": "#272a57",
            "íˆ¬í˜¸ëŒ€ê²°": "#272a57",
            "ì˜ì§€": "#d8d5a8",
            "ê°•í˜¸ì˜ë²—": "#fbceb1",
            "ìœ ë¬¼": "#003458",
            "íƒë°©": "#fbceb1",
            "ìƒê¸°": "#fbceb1",
            "ì—½ìí¬": "#fbceb1",
            "ë§Œë¬¼ì˜ìš¸ë¦¼": "#fbceb1", "ê³¡ê²½ì‹¬ìœ ": "#fbceb1", "ê¶ìˆ ëŒ€ê²°": "#fbceb1", "ê¸°íƒ€": "#fbceb1", "ì•¼ì™¸ì œì‚¬": "#fbceb1",
            "ë¬´ìˆ ë¡œë§ºì€ì¸ì—°": "#fbceb1", "í™”ìˆ ë…¼ìŸ": "#fbceb1", "í’ë¥˜ì˜ì„ ë¥ ": "#fbceb1", "ì˜ìˆ ì¹˜ìœ ": "#fbceb1", "ì±„ì§‘": "#b1fbba",
            "ì—½ìí¬": "#b1fbba",
            "í™”ì¥ì‹¤": "#ebebeb"

        };



        // URL íŒŒë¼ë¯¸í„° ì²˜ë¦¬
        const urlParams = new URLSearchParams(window.location.search);
        let rawId = urlParams.get('id') || "qinghe";
        const isDevMode = rawId.endsWith('_dev');
        let currentMapId = isDevMode ? rawId.replace('_dev', '') : rawId;

        if (!mapsDB[currentMapId]) currentMapId = "qinghe";
        const currentConfig = mapsDB[currentMapId];

        document.title = `${currentConfig.name} - ì—°ìš´ ì§€ë„`;

        // ë§µ ì´ˆê¸°í™”
        const map = L.map('map', {
            crs: L.CRS.Simple, minZoom: -5, maxZoom: 2,
            zoomControl: false, attributionControl: false,
            preferCanvas: true, wheelDebounceTime: 150
        });

        const isMobile = window.innerWidth <= 768;
        const pinSize = isMobile ? [26, 26] : [28, 28];

        if (isDevMode) {
            document.getElementById('map').classList.add('dev-mode-cursor');
            document.getElementById('dev-panel').classList.add('active');
        }

        const bounds = [[0, 0], [currentConfig.h, currentConfig.w]];
        L.imageOverlay(currentConfig.img, bounds).addTo(map);

        const zoomSettings = { pc: -1.5, mobile: -2.5 };
        const targetZoom = isMobile ? zoomSettings.mobile : zoomSettings.pc;
        map.setView([currentConfig.h / 2, currentConfig.w / 2], targetZoom);

        // ë§µ ì„ íƒ ì…€ë ‰íŠ¸ ë°•ìŠ¤
        const mapSelect = document.getElementById('main-map-select');
        for (const [key, val] of Object.entries(mapsDB)) {
            const option = document.createElement('option');
            option.value = key; option.innerText = val.name;
            if (key === currentMapId) option.selected = true;
            mapSelect.appendChild(option);
        }
        mapSelect.onchange = function () {
            const nextId = this.value + (isDevMode ? '_dev' : '');
            window.location.search = `?id=${nextId}`;
        };

        // ì „ì—­ ë³€ìˆ˜
        let pathData = {};
        let currentPathLayer = null;
        let layerGroups = {};
        let allMarkers = [];
        let cachedData = null;
        let isClusterOn = localStorage.getItem('clusterMode') !== 'false';
        let currentPathIds = [];
        let activePathMarkersMap = {};
        let globalMarkerCache = {}; // ëª¨ë“  ë§µì˜ ë§ˆì»¤ ì •ë³´ë¥¼ ë‹´ì„ ì „ì—­ ìºì‹œ

        // Dev Mode ë³€ìˆ˜
        let devRecording = false;
        let devPathList = [];

        document.addEventListener('DOMContentLoaded', () => {
            const targetPath = urlParams.get('path');

            // ê²€ìƒ‰ ê¸°ëŠ¥
            const searchInput = document.getElementById('marker-search');
            const searchResultList = document.getElementById('search-result-list');
            // mapsDBì— ìˆëŠ” ëª¨ë“  JSON ë¡œë“œ
            const fetchPromises = Object.keys(mapsDB).map(key => {
                return fetch(mapsDB[key].json)
                    .then(res => {
                        if (!res.ok) throw new Error(`Failed to load ${key}`);
                        return res.json();
                    })
                    .then(data => ({ key, data }));
            });

            Promise.all(fetchPromises)
                .then(results => {
                    // ê²°ê³¼ë¥¼ globalMarkerCacheì— í†µí•© ì €ì¥
                    results.forEach(({ key, data }) => {
                        data.forEach(item => {
                            // ê° ë§ˆì»¤ì— ì†Œì† map ì •ë³´ë¥¼ ì¶”ê°€í•˜ì—¬ ì €ì¥
                            globalMarkerCache[item.id] = { ...item, map: key };
                        });

                        // í˜„ì¬ ë³´ì—¬ì¤„ ë§µ ë°ì´í„° ì €ì¥
                        if (key === currentMapId) {
                            cachedData = data;
                        }
                    });

                    // í˜„ì¬ ë§µ ë Œë”ë§
                    if (cachedData) {
                        createMarkers(cachedData);
                        generateSidebar(cachedData);
                    } else {
                        console.error("í˜„ì¬ ë§µ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    }

                    // â˜…â˜…â˜… [ìˆ˜ì •ë¨] URLì— marker íŒŒë¼ë¯¸í„°ê°€ ìˆìœ¼ë©´ í•´ë‹¹ ìœ„ì¹˜ë¡œ ì í”„ â˜…â˜…â˜…
                    const targetMarkerId = urlParams.get('marker');
                    // ê²½ë¡œ ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ ì—¬ê¸°ì„œ ë°”ë¡œ ì í”„ (ê²½ë¡œ ëª¨ë“œëŠ” activatePathì—ì„œ ì²˜ë¦¬)
                    if (targetMarkerId && !targetPath) {
                        const targetItem = allMarkers.find(m => m.id == targetMarkerId);
                        if (targetItem) {
                            // í´ëŸ¬ìŠ¤í„° ëª¨ë“œì¸ì§€ í™•ì¸í•˜ì—¬ ì²˜ë¦¬
                            const group = layerGroups[targetItem.type];
                            if (isClusterOn && group && group.zoomToShowLayer) {
                                // í´ëŸ¬ìŠ¤í„° ë‚´ë¶€ì— ìˆ¨ì–´ìˆë‹¤ë©´ í¼ì¹˜ë©´ì„œ ì´ë™
                                group.zoomToShowLayer(targetItem.marker, function () {
                                    targetItem.marker.openPopup();
                                });
                            } else {
                                // í´ëŸ¬ìŠ¤í„°ê°€ ì•„ë‹ˆë©´ ë°”ë¡œ ì´ë™ (ì¤Œ ë ˆë²¨ 0)
                                map.flyTo(targetItem.marker.getLatLng(), 0, { animate: true, duration: 1.0 });
                                map.once('moveend', function () {
                                    targetItem.marker.openPopup();
                                });
                            }
                        }
                    }
                    // â˜…â˜…â˜… ìˆ˜ì • ë â˜…â˜…â˜…

                    loadPathData(false, targetPath);
                })
                .catch(err => {
                    console.warn("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨, ìƒ˜í”Œ ë°ì´í„° ì‚¬ìš©:", err);
                    cachedData = sampleData;
                    // ìƒ˜í”Œ ë°ì´í„°ë„ ì „ì—­ ìºì‹œì— ë“±ë¡
                    sampleData.forEach(item => globalMarkerCache[item.id] = { ...item, map: currentMapId });

                    createMarkers(sampleData);
                    generateSidebar(sampleData);
                    loadPathData(true);
                });
        });

        // Dev Mode ê¸°ëŠ¥
        window.toggleDevRecording = function () {
            devRecording = !devRecording;
            const btn = document.getElementById('dev-record-btn');
            if (devRecording) {
                btn.classList.add('recording');
                btn.innerHTML = "ğŸ”´ REC ON";
            } else {
                btn.classList.remove('recording');
                btn.innerHTML = "âš« REC";
            }
        };

        window.copyDevPath = function () {
            if (devPathList.length === 0) { alert("ì¶”ê°€ëœ ë§ˆì»¤ê°€ ì—†ìŠµë‹ˆë‹¤."); return; }
            const jsonStr = JSON.stringify(devPathList, null, 2);
            navigator.clipboard.writeText(jsonStr).then(() => {
                alert("ê²½ë¡œ ë°ì´í„°ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! path.jsonì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.");
            });
        };

        // ì €ì¥/ë¡œë“œ ë©”ë‰´ í† ê¸€
        window.toggleSaveLoadMenu = function () {
            const menu = document.getElementById('save-load-menu');
            if (menu) menu.classList.toggle('active');
        };

        document.addEventListener('click', function (e) {
            const menu = document.getElementById('save-load-menu');
            const btn = document.querySelector('.bottom-left-controls .glass-box');
            if (menu && menu.classList.contains('active')) {
                if (!menu.contains(e.target) && !btn.contains(e.target)) {
                    menu.classList.remove('active');
                }
            }
        });

        // ê²½ë¡œ ë°ì´í„° ë¡œë“œ í•¨ìˆ˜
        function loadPathData(useSample = false, autoStartPath = null) {
            if (useSample) {
                renderPathList(samplePathData);
                return;
            }
            fetch('../json/path.json')
                .then(res => {
                    if (!res.ok) throw new Error("Path file not found");
                    return res.json();
                })
                .then(data => {
                    renderPathList(data);
                    if (autoStartPath && data[autoStartPath]) {
                        activatePath(autoStartPath);
                    }
                })
                .catch(err => {
                    console.log("Path load failed, using sample:", err);
                    renderPathList(samplePathData);
                });
        }
        // [ìˆ˜ì •] ê²½ë¡œ ë¦¬ìŠ¤íŠ¸ ë Œë”ë§ (ê²€ìƒ‰ì°½ ë³µêµ¬ + ë””ìì¸ ì ìš© + ì²­í•˜ ìš°ì„  ì •ë ¬)
        function renderPathList(data) {
            pathData = data;
            const container = document.getElementById('path-list-dynamic');
            if (!container) return;
            container.innerHTML = '';

            // 1. ê²€ìƒ‰ì°½ ìƒì„± (ë‹¤ì‹œ ì¶”ê°€ë¨)
            const searchWrapper = document.createElement('div');
            searchWrapper.className = 'path-search-wrapper';
            searchWrapper.innerHTML = `
            <span class="path-search-icon">ğŸ”</span>
            <input type="text" class="path-search-input" placeholder="ê²½ë¡œ ê²€ìƒ‰..." onkeyup="filterPathList(this.value)">
        `;
            container.appendChild(searchWrapper);

            // 2. ë°ì´í„° ê·¸ë£¹í™”
            const groups = {};
            for (const [key, info] of Object.entries(pathData)) {
                const catName = info.category ? info.category : 'ì§€ì—­íƒí—˜';
                if (!groups[catName]) groups[catName] = [];
                groups[catName].push({ key, ...info });
            }

            // 3. ì¹´í…Œê³ ë¦¬ ì •ë ¬ ('ì²­í•˜'ë¥¼ ë§¨ ì•ìœ¼ë¡œ)
            const sortedCategories = Object.keys(groups).sort((a, b) => {
                if (a === 'ì²­í•˜') return -1;
                if (b === 'ì²­í•˜') return 1;
                return 0;
            });

            // 4. ë¦¬ìŠ¤íŠ¸ ë Œë”ë§
            sortedCategories.forEach((category, index) => {
                const items = groups[category];

                // ì²« ë²ˆì§¸ë§Œ í¼ì¹¨
                const isFirst = (index === 0);
                const headerClass = isFirst ? 'path-category-header' : 'path-category-header collapsed';
                const gridClass = isFirst ? 'path-category-grid' : 'path-category-grid hidden';

                // (1) ì¹´í…Œê³ ë¦¬ í—¤ë”
                const header = document.createElement('div');
                header.className = headerClass;
                header.innerHTML = `
                <span>${category} <span style="font-size:11px; color:#666; font-weight:400; margin-left:5px;">(${items.length})</span></span>
                <svg class="header-arrow" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>
            `;

                // (2) ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆ
                const gridDiv = document.createElement('div');
                gridDiv.className = gridClass;

                header.onclick = () => {
                    const isHidden = gridDiv.classList.contains('hidden');
                    if (isHidden) {
                        gridDiv.classList.remove('hidden');
                        header.classList.remove('collapsed');
                    } else {
                        gridDiv.classList.add('hidden');
                        header.classList.add('collapsed');
                    }
                };

                // (3) ì•„ì´í…œ ì¶”ê°€
                items.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'path-item';
                    // ê²€ìƒ‰ ê¸°ëŠ¥ì„ ìœ„í•´ ë°ì´í„° ì†ì„± ì¶”ê°€
                    itemDiv.setAttribute('data-name', item.title.toLowerCase());

                    itemDiv.onclick = () => activatePath(item.key);

                    itemDiv.innerHTML = `
                    <svg class="path-icon" viewBox="0 0 24 24">
                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                    </svg>
                    <div class="path-name">${item.title}</div>
                `;
                    gridDiv.appendChild(itemDiv);
                });

                container.appendChild(header);
                container.appendChild(gridDiv);
            });
        }

        // [í•„ìˆ˜] ê²€ìƒ‰ í•„í„° í•¨ìˆ˜ë„ ì—†ìœ¼ë©´ ì•ˆë˜ë¯€ë¡œ í™•ì¸ (ì´ë¯¸ ìˆë‹¤ë©´ íŒ¨ìŠ¤)
        function filterPathList(keyword) {
            const query = keyword.toLowerCase();
            const container = document.getElementById('path-list-dynamic');
            const grids = container.querySelectorAll('.path-category-grid');
            const headers = container.querySelectorAll('.path-category-header');

            grids.forEach((grid, index) => {
                const items = grid.querySelectorAll('.path-item');
                let hasVisibleItem = false;

                items.forEach(item => {
                    const name = item.getAttribute('data-name');
                    if (name.includes(query)) {
                        item.style.display = 'flex';
                        hasVisibleItem = true;
                    } else {
                        item.style.display = 'none';
                    }
                });

                const header = headers[index];
                if (hasVisibleItem) {
                    grid.style.display = 'grid';
                    header.style.display = 'flex';
                    if (query.length > 0) {
                        grid.classList.remove('hidden');
                        header.classList.remove('collapsed');
                    }
                } else {
                    grid.style.display = 'none';
                    header.style.display = 'none';
                }
            });
        }


        // [ì‹ ê·œ] ê²½ë¡œ ê²€ìƒ‰ í•„í„°ë§ í•¨ìˆ˜
        function filterPathList(keyword) {
            const query = keyword.toLowerCase();
            const container = document.getElementById('path-list-dynamic');

            // ëª¨ë“  ì¹´í…Œê³ ë¦¬ ê·¸ë£¹ì„ ìˆœíšŒ
            const grids = container.querySelectorAll('.path-category-grid');
            const headers = container.querySelectorAll('.path-category-header');

            grids.forEach((grid, index) => {
                const items = grid.querySelectorAll('.path-item');
                let hasVisibleItem = false;

                items.forEach(item => {
                    const name = item.getAttribute('data-name');
                    if (name.includes(query)) {
                        item.style.display = 'flex'; // ê²€ìƒ‰ì–´ ë§ìœ¼ë©´ ë³´ì´ê¸°
                        hasVisibleItem = true;
                    } else {
                        item.style.display = 'none'; // ì•„ë‹ˆë©´ ìˆ¨ê¸°ê¸°
                    }
                });

                // í•´ë‹¹ ê·¸ë£¹ì— ë³´ì—¬ì¤„ ì•„ì´í…œì´ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ê·¸ë£¹ í‘œì‹œ
                const header = headers[index];
                if (hasVisibleItem) {
                    grid.style.display = 'grid'; // ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ ë³µêµ¬
                    header.style.display = 'flex';

                    // ê²€ìƒ‰ ì¤‘ì—ëŠ” í¸ì˜ë¥¼ ìœ„í•´ ìë™ìœ¼ë¡œ í¼ì³ì¤Œ
                    if (query.length > 0) {
                        grid.classList.remove('hidden');
                        header.classList.remove('collapsed');
                    }
                } else {
                    // ë³´ì—¬ì¤„ ì•„ì´í…œì´ ì—†ìœ¼ë©´ ê·¸ë£¹ ì „ì²´(í—¤ë”+ê·¸ë¦¬ë“œ) ìˆ¨ê¹€
                    grid.style.display = 'none';
                    header.style.display = 'none';
                }
            });
        }

        window.handlePathButtonClick = function () {
            if (currentPathLayer) {
                clearPath();
            } else {
                const pathPanel = document.getElementById('path-panel');
                if (pathPanel.classList.contains('active')) {
                    closeAllPanels();
                } else {
                    togglePanel('path');
                }
            }
        };

        // [ìˆ˜ì •] ê²½ë¡œ í™œì„±í™” í•¨ìˆ˜ (í‰ë©´ ì¢Œí‘œ ì •ë ¬ ê¸°ëŠ¥ í¬í•¨)
        // [ìˆ˜ì •] ê²½ë¡œ í™œì„±í™” í•¨ìˆ˜ (ì§€ìƒ ìš°ì„  + ê±°ë¦¬ìˆœ ì •ë ¬)
        // [ìˆ˜ì •] ê²½ë¡œ í™œì„±í™” í•¨ìˆ˜ (ì™„ë£Œ ìˆœì„œ ë™ê¸°í™” + ë§µ ì í”„ ê¸°ëŠ¥ ë³µêµ¬)
        function activatePath(pathKey) {
            clearPath();
            document.body.classList.add('viewing-path'); // â˜… [ì¶”ê°€] ê²½ë¡œ ëª¨ë“œ í´ë˜ìŠ¤ ë¶€ì°©
            const routeData = pathData[pathKey];
            if (!routeData || !routeData.markers) return;

            // ì›ë³¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            const originalRouteIds = routeData.markers;
            activePathMarkersMap = {};

            // -----------------------------------------------------------
            // 1. [ë°ì´í„° ë¶„ë¦¬] í˜„ì¬ ë§µ ë§ˆì»¤ vs ë‹¤ë¥¸ ë§µ ë§ˆì»¤
            // -----------------------------------------------------------
            let localMarkerItems = []; // í˜„ì¬ ë§µì— ì°ì„ ë§ˆì»¤ ê°ì²´ë“¤ (ì •ë ¬ ëŒ€ìƒ)
            let otherMapEntries = [];  // ë‹¤ë¥¸ ë§µì— ìˆëŠ” ë°ì´í„°ë“¤ (ìˆœì„œ ìœ ì§€)

            originalRouteIds.forEach(entry => {
                let mId, mMap;
                // ID/Map ì •ë³´ ì¶”ì¶œ
                if (typeof entry === 'object') {
                    mId = entry.id; mMap = entry.map;
                } else {
                    mId = entry;
                    // ì „ì—­ ìºì‹œ í™•ì¸
                    const cached = globalMarkerCache[mId] || globalMarkerCache[Number(mId)] || globalMarkerCache[String(mId)];
                    mMap = cached ? cached.map : currentMapId; // ì •ë³´ ì—†ìœ¼ë©´ í˜„ì¬ ë§µìœ¼ë¡œ ê°€ì •
                }

                if (mMap === currentMapId) {
                    // í˜„ì¬ ë§µ ë§ˆì»¤ë¼ë©´: ì •ë ¬ì„ ìœ„í•´ ë§ˆì»¤ ê°ì²´(x,y í¬í•¨)ë¥¼ ì°¾ì•„ì„œ ë„£ìŒ
                    const item = allMarkers.find(m => m.id == mId);
                    if (item) localMarkerItems.push(item);
                } else {
                    // ë‹¤ë¥¸ ë§µ ë§ˆì»¤ë¼ë©´: ë‚˜ì¤‘ì— ë’¤ì— ë¶™ì´ê¸° ìœ„í•´ ë”°ë¡œ ë³´ê´€
                    otherMapEntries.push(typeof entry === 'object' ? entry : { id: mId, map: mMap });
                }
            });

            // -----------------------------------------------------------
            // 2. [ì •ë ¬ ë¡œì§] ì§€ìƒ ìš°ì„  + ê±°ë¦¬ìˆœ ì •ë ¬ (TSP)
            // -----------------------------------------------------------
            function solveTSP(list, startPoint) {
                if (list.length === 0) return [];
                let sorted = [];
                let remaining = [...list];

                // ì‹œì‘ì  ê²°ì • (ê¸°ì¤€ì ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒë¶€í„°)
                if (startPoint) {
                    let nearestIndex = -1;
                    let minDist = Infinity;
                    remaining.forEach((item, index) => {
                        const p2 = item.marker.getLatLng();
                        const dist = (startPoint.lng - p2.lng) ** 2 + (startPoint.lat - p2.lat) ** 2;
                        if (dist < minDist) { minDist = dist; nearestIndex = index; }
                    });
                    if (nearestIndex !== -1) {
                        sorted.push(remaining[nearestIndex]);
                        remaining.splice(nearestIndex, 1);
                    }
                } else {
                    sorted.push(remaining[0]);
                    remaining.splice(0, 1);
                }

                // ë‚˜ë¨¸ì§€ ì—°ê²°
                while (remaining.length > 0) {
                    const current = sorted[sorted.length - 1];
                    const p1 = current.marker.getLatLng();
                    let nearestIndex = -1;
                    let minDist = Infinity;

                    remaining.forEach((item, index) => {
                        const p2 = item.marker.getLatLng();
                        const dist = (p1.lng - p2.lng) ** 2 + (p1.lat - p2.lat) ** 2;
                        if (dist < minDist) { minDist = dist; nearestIndex = index; }
                    });

                    if (nearestIndex !== -1) {
                        sorted.push(remaining[nearestIndex]);
                        remaining.splice(nearestIndex, 1);
                    } else {
                        sorted.push(...remaining);
                        break;
                    }
                }
                return sorted;
            }

            // ì •ë ¬ ì‹¤í–‰
            let sortedLocalItems = [];
            if (localMarkerItems.length > 0) {
                const normalItems = localMarkerItems.filter(i => !i.name.includes('(ì§€í•˜)'));
                const undergroundItems = localMarkerItems.filter(i => i.name.includes('(ì§€í•˜)'));

                const sortedNormal = solveTSP(normalItems, null);

                let lastPoint = null;
                if (sortedNormal.length > 0) {
                    lastPoint = sortedNormal[sortedNormal.length - 1].marker.getLatLng();
                }
                const sortedUnderground = solveTSP(undergroundItems, lastPoint);

                sortedLocalItems = [...sortedNormal, ...sortedUnderground];
            }

            // -----------------------------------------------------------
            // 3. [í•µì‹¬ ìˆ˜ì •] ì‹¤ì œ ì´ë™ ê²½ë¡œ ë°ì´í„°(currentPathIds) ì¬êµ¬ì„±
            //    (ì •ë ¬ëœ í˜„ì¬ ë§µ ë§ˆì»¤ + ë‹¤ë¥¸ ë§µ ë§ˆì»¤)
            // -----------------------------------------------------------
            const sortedLocalEntries = sortedLocalItems.map(item => ({ id: item.id, map: currentMapId }));

            // â˜…â˜…â˜… ì´ ë¶€ë¶„ì´ ì¤‘ìš”! ì™„ë£Œ ì‹œ ì´ë™í•  ìˆœì„œë¥¼ ì •ë ¬ëœ ìˆœì„œë¡œ ë®ì–´ì”Œì›ë‹ˆë‹¤. â˜…â˜…â˜…
            currentPathIds = [...sortedLocalEntries, ...otherMapEntries];

            // ë§Œì•½ í˜„ì¬ ë§µì— í‘œì‹œí•  ê²Œ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ ì´ë™ (ê¸°ì¡´ ë¡œì§)
            if (sortedLocalItems.length === 0 && otherMapEntries.length > 0) {
                const nextTarget = otherMapEntries[0];
                localStorage.setItem('activePathKey', pathKey);
                window.location.href = `?id=${nextTarget.map}&marker=${nextTarget.id}&path=${pathKey}`;
                return;
            }

            // -----------------------------------------------------------
            // 4. [ê·¸ë¦¬ê¸°] ë§ˆì»¤ ë° ì„  ë Œë”ë§
            // -----------------------------------------------------------
            const storageKey = `completed_${currentMapId}`;
            const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];

            // ê¸°ì¡´ ë ˆì´ì–´ ì •ë¦¬
            for (const key in layerGroups) { map.removeLayer(layerGroups[key]); }
            const filterGroup = document.querySelector('.bottom-right-controls .glass-group');
            if (filterGroup) filterGroup.style.display = 'none';

            currentPathLayer = L.featureGroup();
            const latlngs = [];

            sortedLocalItems.forEach((item, index) => {
                const latlng = item.marker.getLatLng();
                latlngs.push(latlng);

                const itemIconPath = `../images/${typeMapping[item.type] || 'logo'}.png`;
                const isCompleted = completedList.includes(item.id);
                const completedClass = isCompleted ? 'marker-completed' : '';

                // â˜… [ì í”„ ë³µêµ¬] í˜„ì¬ ë§µì˜ ë§ˆì§€ë§‰ ë§ˆì»¤ì´ë©´ì„œ, ë‹¤ìŒì— ê°ˆ ë§µì´ ë‚¨ì•„ìˆë‹¤ë©´ Gateway í‘œì‹œ
                let isGateway = false;
                if (index === sortedLocalItems.length - 1 && otherMapEntries.length > 0) {
                    isGateway = true;
                }

                const gatewayClass = isGateway ? 'gateway-marker' : '';
                let badgeContent = index + 1;

                // ê²Œì´íŠ¸ì›¨ì´ ì•„ì´ì½˜ (í™”ì‚´í‘œ)
                if (isGateway) {
                    badgeContent = `<svg viewBox="0 0 24 24" style="width:12px;height:12px;fill:black;"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>`;
                }

                const pathIcon = L.divIcon({
                    className: `custom-div-icon ${completedClass} ${gatewayClass}`,
                    html: `<div class="path-marker-box">
                           <img src="${itemIconPath}" class="path-marker-icon" onerror="this.src='../images/stone.png'">
                           <div class="path-order-badge">${badgeContent}</div>
                       </div>`,
                    iconSize: [34, 34], iconAnchor: [17, 17], popupAnchor: [0, -20]
                });

                const markerClone = L.marker(latlng, { icon: pathIcon })
                    .bindPopup(item.marker.getPopup().getContent());

                currentPathLayer.addLayer(markerClone);
                activePathMarkersMap[item.id] = markerClone;
            });

            // ì„  ê·¸ë¦¬ê¸°
            if (latlngs.length > 1) {
                const polyline = L.polyline(latlngs, {
                    color: '#a08040', weight: 4, opacity: 0.9, dashArray: '5, 10', lineJoin: 'round'
                });
                currentPathLayer.addLayer(polyline);
            }

            currentPathLayer.addTo(map);
            document.getElementById('path-toggle-btn').classList.add('path-active');

            // 5. ì‹œì‘ì  ì´ë™ (URL íŒŒë¼ë¯¸í„° or ì •ë ¬ëœ ì²« ë²ˆì§¸)
            const targetMarkerId = new URLSearchParams(window.location.search).get('marker');
            let jumpTarget = latlngs.length > 0 ? latlngs[0] : null;
            let targetMarkerObj = null;

            if (targetMarkerId && activePathMarkersMap[targetMarkerId]) {
                targetMarkerObj = activePathMarkersMap[targetMarkerId];
                jumpTarget = targetMarkerObj.getLatLng();
            }

            if (jumpTarget) {
                map.flyTo(jumpTarget, 0, { animate: true, duration: 1.5 });
                if (targetMarkerObj) {
                    map.once('moveend', () => targetMarkerObj.openPopup());
                }
            }

            localStorage.setItem('activePathKey', pathKey);
            updatePathSummaryUI();
            closeAllPanels();
        }
        function isGateway(index, routeIds) {
            if (index >= routeIds.length - 1) return false;
            const currentEntry = routeIds[index];
            const nextEntry = routeIds[index + 1];

            // í˜„ì¬ ë§ˆì»¤ì˜ ë§µ
            let currentMap = (typeof currentEntry === 'object') ? currentEntry.map : (globalMarkerCache[currentEntry]?.map || currentMapId);

            // ë‹¤ìŒ ë§ˆì»¤ì˜ ë§µ
            let nextMap = (typeof nextEntry === 'object') ? nextEntry.map : (globalMarkerCache[nextEntry]?.map || currentMapId);

            return currentMap === currentMapId && nextMap !== currentMapId;
        }

        // ê²½ë¡œ ì¢…ë£Œ ë° UI ë³µì›
        function clearPath() {
            document.body.classList.remove('viewing-path'); // â˜… [ì¶”ê°€] ê²½ë¡œ ëª¨ë“œ í•´ì œ
            if (currentPathLayer) {
                map.removeLayer(currentPathLayer);
                currentPathLayer = null;
                currentPathIds = [];
                activePathMarkersMap = {};
                localStorage.removeItem('activePathKey');
            }
            document.getElementById('path-toggle-btn').classList.remove('path-active');

            // ìš”ì•½ ë°” ìˆ¨ê¸°ê¸°
            const summaryBar = document.getElementById('path-summary-bar');
            if (summaryBar) summaryBar.style.display = 'none';

            // í•„í„° ë²„íŠ¼ ë‹¤ì‹œ ë³´ì´ê¸°
            const filterGroup = document.querySelector('.bottom-right-controls .glass-group');
            if (filterGroup) filterGroup.style.display = 'flex';

            // ê¸°ì¡´ í•„í„° ìƒíƒœ ë³µì›
            const savedFilters = JSON.parse(localStorage.getItem('map_filter_settings')) || {};
            // [ìˆ˜ì •] í•„í„° ìƒíƒœ ë°˜ì˜ (ì´ˆê¸° ì§„ì… ì‹œ 'ê²½ê³„ì„', 'ë§Œì‚¬ë¡'ë§Œ í‘œì‹œ)
            const defaultVisible = ["ê²½ê³„ì„", "ë§Œì‚¬ë¡"]; // â˜… ì—¬ê¸°ì— ì²˜ìŒ ë³´ì—¬ì¤„ ê²ƒë“¤ë§Œ ì ìœ¼ì„¸ìš”

            for (const key in layerGroups) {
                let shouldShow;

                // 1. ì‚¬ìš©ìê°€ ì´ì „ì— ì €ì¥í•œ í•„í„° ì„¤ì •ì´ ìˆìœ¼ë©´ ê·¸ê±¸ ë”°ë¦„
                if (savedFilters[key] !== undefined) {
                    shouldShow = savedFilters[key];
                }
                // 2. ì €ì¥ëœ ì„¤ì •ì´ ì—†ìœ¼ë©´(ì²« ì§„ì…) ìœ„ì—ì„œ ì •í•œ ëª©ë¡ë§Œ ë³´ì—¬ì¤Œ
                else {
                    shouldShow = defaultVisible.includes(key);
                }

                if (shouldShow) {
                    layerGroups[key].addTo(map);
                }
            }
        }

        function togglePanel(type) {
            const searchPanel = document.getElementById('search-panel');
            const filterPanel = document.getElementById('filter-panel');
            const pathPanel = document.getElementById('path-panel');

            searchPanel.classList.remove('active');
            filterPanel.classList.remove('active');
            pathPanel.classList.remove('active');

            if (type === 'path') {
                pathPanel.classList.add('active');
            } else if (type === 'search') {
                searchPanel.classList.add('active');
                document.getElementById('marker-search').focus();
            } else if (type === 'filter') {
                filterPanel.classList.add('active');
            }
        }

        function closeAllPanels() {
            document.getElementById('search-panel').classList.remove('active');
            document.getElementById('filter-panel').classList.remove('active');
            document.getElementById('path-panel').classList.remove('active');
        }

        // ë§ˆì»¤ ìƒì„± í•¨ìˆ˜
       function createMarkers(data) {
    const storageKey = `completed_${currentMapId}`;
    const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];
    const savedFilters = JSON.parse(localStorage.getItem('map_filter_settings')) || {};

    // ì´ˆê¸°í™”
    for (const key in layerGroups) { map.removeLayer(layerGroups[key]); }
    allMarkers = [];
    layerGroups = {};

    const markersByType = {};
    let index = 0;
    const CHUNK_SIZE = 500; // í•œ ë²ˆì— ì²˜ë¦¬í•  ì–‘

    function processChunk() {
        const chunk = data.slice(index, index + CHUNK_SIZE);
        
        chunk.forEach(item => {
            if (!markersByType[item.type]) {
                // í´ëŸ¬ìŠ¤í„° ì„¤ì • ìµœì í™” ì ìš©
                if (isClusterOn) {
                    markersByType[item.type] = createClusterGroup(item.type);
                } else {
                    markersByType[item.type] = L.layerGroup();
                }
            }

            const isCompleted = completedList.includes(item.id);
            const imgName = typeMapping[item.type] || "stone";
            const iconPath = `../images/${imgName}.png`;
            const pinColor = colorMapping[item.type] || "#555";

            const pinIcon = L.divIcon({
                className: isCompleted ? 'marker-completed' : '',
                html: `<div class="pin-marker" style="--pin-color: ${pinColor};">
                         <div class="pin-inner-circle">
                           <img src="${iconPath}" onerror="this.src='../images/stone.png'">
                         </div>
                       </div>`,
                iconSize: pinSize,
                iconAnchor: [pinSize[0] / 2, pinSize[1] / 2],
                popupAnchor: [0, -(pinSize[1] / 2 + 5)]
            });

            const marker = L.marker([item.y, item.x], { icon: pinIcon });
            marker.bindPopup(() => generatePopupContent(item, storageKey));
            
            // ë ˆì´ì–´ ê·¸ë£¹ì— ì¶”ê°€
            markersByType[item.type].addLayer(marker);
            
            allMarkers.push({ 
                id: item.id, name: item.name, desc: item.desc || "", 
                type: item.type, marker: marker 
            });
        });

        index += CHUNK_SIZE;

        if (index < data.length) {
            // ë¸Œë¼ìš°ì €ì—ê²Œ ìˆ¨ ëŒë¦´ í‹ˆì„ ì£¼ê³  ë‹¤ìŒ ë©ì–´ë¦¬ ì²˜ë¦¬
            requestAnimationFrame(processChunk);
        } else {
            // ëª¨ë“  ë§ˆì»¤ ìƒì„±ì´ ëë‚˜ë©´ ë§µì— í‘œì‹œ
            finalizeMarkers(markersByType, savedFilters);
        }
    }

    processChunk();
}

// í´ëŸ¬ìŠ¤í„° ê·¸ë£¹ ìƒì„±ì„ ë¶„ë¦¬í•˜ì—¬ ìµœì í™” ì˜µì…˜ ì ìš©
function createClusterGroup(type) {
    const typeColor = colorMapping[type] || "#555";
    return L.markerClusterGroup({
        chunkedLoading: true,
        chunkInterval: 50,
        chunkDelay: 20,
        disableClusteringAtZoom: 0,
        maxClusterRadius: 70,
        iconCreateFunction: function (cluster) {
            const count = cluster.getChildCount();
            return L.divIcon({
                html: `<div class="simple-cluster-marker" style="--cluster-color: ${typeColor};">${count}</div>`,
                className: '', iconSize: [30, 30], iconAnchor: [15, 15]
            });
        }
    });
}

function finalizeMarkers(groups, savedFilters) {
    layerGroups = groups;
    for (const key in layerGroups) {
        const shouldShow = (savedFilters[key] !== undefined) ? savedFilters[key] : true;
        if (shouldShow) { layerGroups[key].addTo(map); }
    }
}
            const storageKey = `completed_${currentMapId}`;
            const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];
            const savedFilters = JSON.parse(localStorage.getItem('map_filter_settings')) || {};

            // ê¸°ì¡´ ë ˆì´ì–´ ê·¸ë£¹ì´ ìˆë‹¤ë©´ ë§µì—ì„œ ì œê±°
            for (const key in layerGroups) {
                map.removeLayer(layerGroups[key]);
            }

            allMarkers = [];
            layerGroups = {}; // ì´ˆê¸°í™”
            const markersByType = {};

            try {
                data.forEach(item => {
                    // íƒ€ì…ë³„ ë°°ì—´ ì´ˆê¸°í™”
                    if (!markersByType[item.type]) { markersByType[item.type] = []; }

                    const isCompleted = completedList.includes(item.id);
                    const imgName = typeMapping[item.type] || "stone";
                    const iconPath = `../images/${imgName}.png`;
                    const pinColor = colorMapping[item.type] || "#555";

                    // ê¸°ì¡´ pinIcon ì •ì˜ ë¶€ë¶„ì„ ì•„ë˜ ì½”ë“œë¡œ êµì²´í•˜ì„¸ìš”.
                    // createMarkers í•¨ìˆ˜ ë‚´ë¶€ì˜ pinIcon ì •ì˜ë¥¼ ì´ê±¸ë¡œ ë®ì–´ì“°ì„¸ìš”.

                    /* ì°¾ì„ ìœ„ì¹˜: createMarkers í•¨ìˆ˜ ë‚´ë¶€
                       ìˆ˜ì • ë‚´ìš©: style ì†ì„±ì„ ë°”ê¹¥ìª½ div(.pin-marker)ë¡œ ì´ë™
                    */

                    // [ìˆ˜ì •] ì¼ë°˜ í•€ ì•„ì´ì½˜ ì •ì˜ (ìƒ‰ìƒ ì •ë³´ë¥¼ ë¶€ëª¨ divë¡œ ì´ë™ + ì•µì»¤ ìˆ˜ì •)
                    const pinIcon = L.divIcon({
                        className: isCompleted ? 'marker-completed' : '',
                        // â˜… í•µì‹¬ ë³€ê²½: style="--pin-color..."ë¥¼ ë°”ê¹¥ìª½ div(.pin-marker)ë¡œ ì˜®ê²¼ìŠµë‹ˆë‹¤.
                        html: `<div class="pin-marker" style="--pin-color: ${pinColor};">
                               <div class="pin-inner-circle">
                                   <img src="${iconPath}" onerror="this.src='../images/stone.png'">
                               </div>
                           </div>`,

                        // ëª¨ì–‘ì´ ì›í˜•ìœ¼ë¡œ ë°”ë€Œë¯€ë¡œ ì¤‘ì‹¬ì (Anchor)ë„ ì •ì¤‘ì•™ìœ¼ë¡œ ë§ì¶°ì•¼ í•©ë‹ˆë‹¤.
                        iconSize: pinSize,
                        iconAnchor: [pinSize[0] / 2, pinSize[1] / 2],
                        popupAnchor: [0, -(pinSize[1] / 2 + 5)]
                    });
                    const marker = L.marker([item.y, item.x], { icon: pinIcon });

                    // Dev Mode í´ë¦­ ì´ë²¤íŠ¸ (ë…¹í™” ë° ìƒíƒœ í‘œì‹œ)
                    // Dev Mode í´ë¦­ ì´ë²¤íŠ¸ (íƒ€ì…ë³„ ì „ì²´ ì§‘ê³„ ê¸°ëŠ¥)
                    marker.on('click', () => {
                        if (devRecording) {
                            const existingIndex = devPathList.findIndex(entry => entry.id === item.id && entry.map === currentMapId);

                            // 1. ë¦¬ìŠ¤íŠ¸ ì¶”ê°€/ì œê±°
                            if (existingIndex > -1) {
                                devPathList.splice(existingIndex, 1);
                                L.DomUtil.removeClass(marker._icon, 'dev-selected');
                            } else {
                                devPathList.push({ id: item.id, map: currentMapId });
                                L.DomUtil.addClass(marker._icon, 'dev-selected');
                            }

                            // 2. ì „ì²´ ê°œìˆ˜ ì—…ë°ì´íŠ¸
                            document.getElementById('dev-count').innerText = devPathList.length;

                            // â˜… 3. [í•µì‹¬] í˜„ì¬ ë‹´ê¸´ ëª¨ë“  ë§ˆì»¤ì˜ íƒ€ì…ë³„ ê°œìˆ˜ ê³„ì‚°
                            const typeCounts = {};

                            devPathList.forEach(entry => {
                                // ë§ˆì»¤ ì •ë³´ ì°¾ê¸° (ì „ì—­ ìºì‹œ ìš°ì„ , ì—†ìœ¼ë©´ í˜„ì¬ ë§µ ë¦¬ìŠ¤íŠ¸)
                                let targetInfo = globalMarkerCache[entry.id];
                                if (!targetInfo) {
                                    targetInfo = allMarkers.find(m => m.id == entry.id);
                                }

                                // íƒ€ì… ì¹´ìš´íŒ…
                                if (targetInfo && targetInfo.type) {
                                    typeCounts[targetInfo.type] = (typeCounts[targetInfo.type] || 0) + 1;
                                }
                            });

                            // 4. í™”ë©´ì— ìš”ì•½í•´ì„œ ë³´ì—¬ì£¼ê¸°
                            const statusBox = document.getElementById('dev-status');
                            if (statusBox) {
                                // "íƒ€ì… ê°¯ìˆ˜" ë¬¸ìì—´ ìƒì„± (ì˜ˆ: ìƒì 2 | ë³´ìŠ¤ 1)
                                const summaryHtml = Object.entries(typeCounts)
                                    .map(([type, count]) =>
                                        `<span><span class="dev-type-tag">${type}</span> <span class="dev-type-count">${count}</span></span>`
                                    )
                                    .join('<span style="color:#555; margin:0 6px;">|</span>'); // êµ¬ë¶„ì

                                if (summaryHtml) {
                                    statusBox.innerHTML = summaryHtml;
                                    statusBox.style.display = 'flex';
                                } else {
                                    statusBox.style.display = 'none';
                                }
                            }
                        }
                        // ì¼ë°˜ ëª¨ë“œ íŒì—…
                    });

                    marker.bindPopup(() => generatePopupContent(item, storageKey));
                    markersByType[item.type].push(marker);
                    allMarkers.push({ id: item.id, name: item.name, desc: item.desc || "", type: item.type, marker: marker });
                });

                // í´ëŸ¬ìŠ¤í„° ë˜ëŠ” ì¼ë°˜ ë ˆì´ì–´ ê·¸ë£¹ ìƒì„±
                for (const type in markersByType) {
                    const markersArray = markersByType[type];
                    if (isClusterOn) {
                        const typeColor = colorMapping[type] || "#555";
                        if (!layerGroups[type]) {
                            layerGroups[type] = L.markerClusterGroup({
                                disableClusteringAtZoom: 0, spiderfyOnMaxZoom: true, showCoverageOnHover: false,
                                chunkedLoading: true, chunkInterval: 200,
                                animate: false, animateAddingMarkers: false, maxClusterRadius: 80,
                                iconCreateFunction: function (cluster) {
                                    const count = cluster.getChildCount();
                                    const countText = count > 99 ? '99+' : count;
                                    // ë°°ê²½ìƒ‰ ëŒ€ì‹  CSS ë³€ìˆ˜ë¡œ ìƒ‰ìƒ ì •ë³´ë§Œ ì „ë‹¬
                                    const html = `
                                    <div class="simple-cluster-marker" style="--cluster-color: ${typeColor};">
                                        ${countText}
                                    </div>`;

                                    return L.divIcon({
                                        html: html, className: '', iconSize: [30, 30], iconAnchor: [15, 15]
                                    });
                                }
                            });
                        }
                        layerGroups[type].addLayers(markersArray);
                    } else {
                        if (!layerGroups[type]) { layerGroups[type] = L.layerGroup(); }
                        markersArray.forEach(m => layerGroups[type].addLayer(m));
                    }
                }

                // í•„í„° ìƒíƒœ ë°˜ì˜
                for (const key in layerGroups) {
                    const shouldShow = (savedFilters[key] !== undefined) ? savedFilters[key] : true;
                    if (shouldShow) { layerGroups[key].addTo(map); }
                }
            } catch (e) { console.error("Marker creation error:", e); }


        // ì‚¬ì´ë“œë°” í•„í„° ìƒì„±
        function generateSidebar(data) {
    const filterList = document.getElementById('filter-list');
    if (!filterList) return;
    filterList.innerHTML = '';

    const savedFilters = JSON.parse(localStorage.getItem('map_filter_settings')) || {};
    const counts = {};
    
    // ë°ì´í„° ì§‘ê³„
    data.forEach(item => counts[item.type] = (counts[item.type] || 0) + 1);

    // DocumentFragmentë¥¼ ì‚¬ìš©í•˜ì—¬ í•œ ë²ˆë§Œ DOMì— ì‚½ì… (ì„±ëŠ¥ í–¥ìƒ)
    const fragment = document.createDocumentFragment();

    Object.entries(counts).forEach(([type, count]) => {
        const div = document.createElement('div');
        const isActive = (savedFilters[type] !== undefined) ? savedFilters[type] : true;

        div.className = `filter-item ${isActive ? 'active' : 'inactive'}`;
        const imgName = typeMapping[type] || "stone";
        div.innerHTML = `
            <div class="filter-left-group">
                <img src="../images/${imgName}.png" class="filter-icon-img">
                <span class="filter-text-name">${type}</span>
            </div>
            <span class="filter-count">${count}</span>`;
            
        div.onclick = function () {
            const isNowActive = div.classList.toggle('active');
            div.classList.toggle('inactive', !isNowActive);
            toggleLayer(type, isNowActive);
            saveFilterState();
        };
        fragment.appendChild(div);
    });

    filterList.appendChild(fragment);
}

        function saveFilterState() {
            const status = {};
            for (const key in layerGroups) {
                status[key] = map.hasLayer(layerGroups[key]);
            }
            localStorage.setItem('map_filter_settings', JSON.stringify(status));
        }

        function toggleLayer(type, isChecked) {
            if (isChecked) { if (layerGroups[type]) map.addLayer(layerGroups[type]); }
            else { if (layerGroups[type]) map.removeLayer(layerGroups[type]); }
        }

        function setAllFilters(status) {
            const items = document.querySelectorAll('.filter-item');
            items.forEach(div => {
                const typeName = div.querySelector('.filter-text-name').innerText;
                if (status) {
                    div.classList.remove('inactive'); div.classList.add('active');
                    toggleLayer(typeName, true);
                } else {
                    div.classList.remove('active'); div.classList.add('inactive');
                    toggleLayer(typeName, false);
                }
            });
            saveFilterState();
        }


        searchInput.addEventListener('input', function (e) {
            const keyword = e.target.value.trim().toLowerCase();
            searchResultList.innerHTML = '';
            if (keyword === "") {
                searchResultList.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>';
                return;
            }
            const results = allMarkers.filter(item => item.name.toLowerCase().includes(keyword) || item.desc.toLowerCase().includes(keyword));
            if (results.length === 0) {
                searchResultList.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }
            results.forEach(item => {
                const row = document.createElement('div'); row.className = 'search-result-row';
                const imgName = typeMapping[item.type] || "stone";
                row.innerHTML = `<div class="result-info"><div class="result-name">${item.name}</div><div class="result-desc">${item.desc}</div></div><img src="../images/${imgName}.png" class="result-type-icon" onerror="this.style.display='none'">`;

                row.onclick = () => {
                    if (!map.hasLayer(layerGroups[item.type])) map.addLayer(layerGroups[item.type]);
                    const jumpZoom = Math.min(map.getZoom() + 3, 1);
                    map.flyTo(item.marker.getLatLng(), jumpZoom, { animate: true, duration: 1.5 });

                    map.once('moveend', function () { item.marker.openPopup(); });
                    if (window.innerWidth <= 480) closeAllPanels();
                };
                searchResultList.appendChild(row);
            });
        });

        // íŒì—… ë‚´ìš© ìƒì„±
        // íŒì—… ë‚´ìš© ìƒì„± (Dev ëª¨ë“œ ID ë³µì‚¬ ë²„íŠ¼ ì¶”ê°€ë¨)
        function generatePopupContent(item, storageKey) {
            const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];
            const isCompleted = completedList.includes(item.id);

            let html = `<div class="popup-inner">`;

            // â˜… [Dev ëª¨ë“œ ì „ìš©] ID ë³µì‚¬ ë²„íŠ¼ ì¶”ê°€
            if (typeof isDevMode !== 'undefined' && isDevMode) {
                html += `<div onclick="copyToClipboard('${item.id}'); alert('ID ${item.id} ë³µì‚¬ ì™„ë£Œ!');" 
                          style="cursor:pointer; margin-bottom:10px; padding:6px; background:rgba(0, 229, 255, 0.1); border:1px solid #00e5ff; color:#00e5ff; border-radius:6px; font-size:12px; font-weight:bold; display:flex; align-items:center; justify-content:center; gap:5px;">
                          ğŸ›  ID ë³µì‚¬: ${item.id}
                     </div>`;
            }

            html += `<span class="popup-title">${item.name}</span><div class="popup-type-badge">${item.type}</div>`;

            if (item.image) {
                const ytId = getYouTubeId(item.image);
                if (ytId) {
                    html += `<div class="popup-youtube-container"><iframe src="https://www.youtube.com/embed/${ytId}" frameborder="0" allowfullscreen></iframe></div>`;
                } else {
                    html += `<img src="${item.image}" class="popup-img" alt="${item.name}">`;
                }
            }
            if (item.desc) html += `<div class="popup-desc">${item.desc}</div>`;

            html += `<div class="btn-container"><button onclick="shareMarker(${item.id})" class="action-btn btn-wiki">ğŸ”— ê³µìœ </button>`;
            // ê¸°ì¡´ ì½”ë“œ
            if (item.link) {
                html += `<a href="${item.link}" target="_blank" class="action-btn btn-wiki" style="color: white !important;">ğŸ“– ê³µëµ</a>`;
            }

            const btnText = isCompleted ? "ì·¨ì†Œ" : "ì™„ë£Œ";
            const btnClass = isCompleted ? "btn-undo" : "btn-complete";
            html += `<button onclick="toggleComplete(${item.id}, '${storageKey}')" class="action-btn ${btnClass}">${btnText}</button></div></div>`;
            return html;
        }



        // [ìˆ˜ì •] ë§ˆì»¤ ì™„ë£Œ ìƒíƒœ í† ê¸€ í•¨ìˆ˜ (íŒì—… ë‹«ê¸° ì¶”ê°€)
        // [ìˆ˜ì •] ë§ˆì»¤ ì™„ë£Œ ìƒíƒœ í† ê¸€ í•¨ìˆ˜ (íŒì—… ë‹«ê¸° + â˜…ë‹¤ìŒ ë§ˆì»¤ ìë™ ì´ë™â˜…)
        // [ìµœì¢… ìˆ˜ì •] í™”ë©´ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ í—¬í¼ (ì›ë³¸/ê²½ë¡œëª¨ë“œ ë™ì‹œ ì ìš©)
        function updateMarkerVisuals(id, isComplete) {

            // 1. í—¬í¼ í•¨ìˆ˜: íŠ¹ì • ë§ˆì»¤ ê°ì²´ì˜ ìŠ¤íƒ€ì¼ì„ ë³€ê²½
            const applyStyle = (markerObj) => {
                if (!markerObj) return;

                // ë§ˆì»¤ì˜ HTML ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
                const el = markerObj.getElement();
                if (el) {
                    // A. í´ë˜ìŠ¤ í† ê¸€ (CSS í•„í„° ì ìš©ìš©)
                    if (isComplete) {
                        el.classList.add('marker-completed');
                    } else {
                        el.classList.remove('marker-completed');
                    }

                    // B. ë‚´ë¶€ ì•„ì´ì½˜(.custom-div-icon)ì—ë„ í´ë˜ìŠ¤ ì „ë‹¬ (ì•ˆì „ì¥ì¹˜)
                    const iconDiv = el.querySelector('.custom-div-icon');
                    if (iconDiv) {
                        if (isComplete) iconDiv.classList.add('marker-completed');
                        else iconDiv.classList.remove('marker-completed');
                    }
                }
            };

            // 2. [ì›ë³¸ ë§ˆì»¤] ì°¾ì•„ì„œ ì—…ë°ì´íŠ¸
            const originalItem = allMarkers.find(m => m.id == id);
            if (originalItem) {
                applyStyle(originalItem.marker);
            }

            // 3. [ê²½ë¡œ ëª¨ë“œ ë§ˆì»¤] ì°¾ì•„ì„œ ì—…ë°ì´íŠ¸ (ë™ê¸°í™” í•µì‹¬!)
            // activePathMarkersMapì€ activatePath í•¨ìˆ˜ì—ì„œ ë§Œë“¤ì–´ì§„ ì „ì—­ ë³€ìˆ˜ì…ë‹ˆë‹¤.
            if (typeof activePathMarkersMap !== 'undefined' && activePathMarkersMap[id]) {
                applyStyle(activePathMarkersMap[id]);
            }

            // 4. [íŒì—… ë²„íŠ¼] í˜„ì¬ ì—´ë ¤ìˆëŠ” íŒì—…ì˜ ë²„íŠ¼ ìƒíƒœ ë³€ê²½
            const popupBtns = document.querySelectorAll('.action-btn'); // íŒì—… ë‚´ ë²„íŠ¼ë“¤
            popupBtns.forEach(btn => {
                // ë²„íŠ¼ì˜ onclick ì´ë²¤íŠ¸ í…ìŠ¤íŠ¸ë¥¼ í™•ì¸í•˜ì—¬ í•´ë‹¹ ID ë²„íŠ¼ì¸ì§€ íŒë³„
                const onClickAttr = btn.getAttribute('onclick');
                if (onClickAttr && onClickAttr.includes(`toggleComplete(${id}`)) {
                    if (isComplete) {
                        btn.innerText = "ì·¨ì†Œ"; // í˜¹ì€ "ì™„ë£Œë¨"
                        btn.classList.remove('btn-complete');
                        btn.classList.add('btn-undo');
                        btn.style.backgroundColor = "#555"; // ì™„ë£Œ ìƒíƒœ ìƒ‰ìƒ
                    } else {
                        btn.innerText = "ì™„ë£Œ";
                        btn.classList.remove('btn-undo');
                        btn.classList.add('btn-complete');
                        btn.style.backgroundColor = ""; // ì›ë˜ ìƒ‰ìƒ ë³µêµ¬
                    }
                }
            });

            // 5. ê²½ë¡œ íŒ¨ë„ ìš”ì•½ ê°±ì‹ 
            if (typeof updatePathSummaryUI === 'function') updatePathSummaryUI();
        }

        // [ìµœì¢… ìˆ˜ì •] ì™„ë£Œ í† ê¸€ í•¨ìˆ˜ (ì‹¤í–‰ íë¦„)
        function toggleComplete(id) {
            // 1. ë°ì´í„° ì €ì¥/ì‚­ì œ
            const storageKey = `completed_${currentMapId}`;
            let completedList = JSON.parse(localStorage.getItem(storageKey)) || [];
            const index = completedList.indexOf(id);
            const isComplete = index === -1; // ë¦¬ìŠ¤íŠ¸ì— ì—†ìœ¼ë©´ -> ì™„ë£Œ ì²˜ë¦¬

            if (isComplete) {
                completedList.push(id);
            } else {
                completedList.splice(index, 1);
            }
            localStorage.setItem(storageKey, JSON.stringify(completedList));

            // 2. ì‹œê°ì  ì—…ë°ì´íŠ¸ (ìœ„ì—ì„œ ë§Œë“  ê°•ë ¥í•œ í•¨ìˆ˜ í˜¸ì¶œ)
            updateMarkerVisuals(id, isComplete);

            // 3. íŒì—… ë‹«ê¸°
            map.closePopup();

            // 4. [ê²½ë¡œ ëª¨ë“œ] ë‹¤ìŒ ë§ˆì»¤ ìë™ ì´ë™ ë¡œì§
            if (isComplete && typeof currentPathIds !== 'undefined' && currentPathIds.length > 0) {
                const currentIndex = currentPathIds.findIndex(item => {
                    const itemId = (typeof item === 'object') ? item.id : item;
                    return itemId == id;
                });

                if (currentIndex !== -1 && currentIndex < currentPathIds.length - 1) {
                    const nextItem = currentPathIds[currentIndex + 1];
                    const nextId = (typeof nextItem === 'object') ? nextItem.id : nextItem;
                    const nextMap = (typeof nextItem === 'object') ? nextItem.map : currentMapId;

                    if (nextMap === currentMapId) {
                        // ê°™ì€ ë§µ: ë¶€ë“œëŸ½ê²Œ ì´ë™
                        const nextMarkerObj = activePathMarkersMap[nextId];
                        if (nextMarkerObj) {
                            map.flyTo(nextMarkerObj.getLatLng(), 0, { animate: true, duration: 1.0 });
                            map.once('moveend', () => nextMarkerObj.openPopup());
                        }
                    } else {
                        // ë‹¤ë¥¸ ë§µ: í˜ì´ì§€ ì´ë™
                        const currentPathKey = localStorage.getItem('activePathKey');
                        setTimeout(() => {
                            window.location.href = `?id=${nextMap}&marker=${nextId}&path=${currentPathKey}`;
                        }, 500);
                    }
                }
            }
        }



        // [ì‹ ê·œ] ë§ˆì»¤ ê³µìœ  í•¨ìˆ˜
        function shareMarker(id) {
            // í˜„ì¬ URLì— idì™€ map íŒŒë¼ë¯¸í„°ë¥¼ ë¶™ì—¬ì„œ í´ë¦½ë³´ë“œì— ë³µì‚¬
            const url = `${window.location.origin}${window.location.pathname}?id=${currentMapId}&marker=${id}`;

            navigator.clipboard.writeText(url).then(() => {
                alert("ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!"); // í˜¹ì€ í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í•¨ìˆ˜ í˜¸ì¶œ
            }).catch(err => {
                console.error('ë³µì‚¬ ì‹¤íŒ¨', err);
            });
        }


        function getYouTubeId(url) {
            if (!url) return null;
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.log(err); }); }
            else { if (document.exitFullscreen) { document.exitFullscreen(); } }
        }

        window.toggleClusterMode = function () {
            // 1. ìƒíƒœ ë°˜ì „ ë° ì €ì¥
            isClusterOn = !isClusterOn;
            localStorage.setItem('clusterMode', isClusterOn);

            // 2. ê²½ë¡œ ëª¨ë“œë¼ë©´ ê²½ë¡œë¥¼ ë¨¼ì € ë„ëŠ” ê²ƒì´ ì•ˆì „í•©ë‹ˆë‹¤ (ì„ íƒ ì‚¬í•­)
            if (currentPathLayer) {
                alert("ê²½ë¡œ ëª¨ë“œ ì¢…ë£Œ í›„ í´ëŸ¬ìŠ¤í„° ì„¤ì •ì´ ì ìš©ë©ë‹ˆë‹¤.");
                clearPath();
                return;
            }

            // 3. ê¸°ì¡´ ëª¨ë“  ë ˆì´ì–´ ì œê±°
            for (const key in layerGroups) {
                map.removeLayer(layerGroups[key]);
            }

            // 4. ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ ì¬ìƒì„± (createMarkers ë‚´ë¶€ì—ì„œ layerGroups ì´ˆê¸°í™”í•¨)
            if (cachedData) {
                createMarkers(cachedData);
                generateSidebar(cachedData);
            }
        };
        // ê¸°ì¡´ window.toggleClusterMode = function() { ... } ë¶€ë¶„ì„ ì•„ë˜ë¡œ êµì²´
        function toggleClusterMode() {
            isClusterOn = !isClusterOn;
            localStorage.setItem('clusterMode', isClusterOn);

            // ê¸°ì¡´ ë ˆì´ì–´ ì œê±°
            for (const key in layerGroups) {
                if (map.hasLayer(layerGroups[key])) {
                    map.removeLayer(layerGroups[key]);
                }
            }

            // ë°ì´í„° ì´ˆê¸°í™” ë° ì¬ìƒì„±
            layerGroups = {};
            allMarkers = [];

            if (cachedData) {
                createMarkers(cachedData);
                generateSidebar(cachedData);
            }
        }
        function exportCompletedPins() {
            try {
                if (!currentMapId) { alert("ë§µ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; }
                const storageKey = `completed_${currentMapId}`;
                const data = localStorage.getItem(storageKey);
                if (!data || data === "[]") { alert("ì €ì¥í•  ì™„ë£Œ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤."); return; }
                const blob = new Blob([data], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url; a.download = `completed_markers_${currentMapId}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) { alert("ì˜¤ë¥˜ ë°œìƒ: " + err.message); }
        }

        function importCompletedPins(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const json = JSON.parse(e.target.result);
                    if (!Array.isArray(json)) throw new Error("Invalid format");
                    if (confirm(`ë¶ˆëŸ¬ì˜¨ ê¸°ë¡ìœ¼ë¡œ í˜„ì¬ ì™„ë£Œ ìƒíƒœë¥¼ ë®ì–´ì“°ì‹œê² ìŠµë‹ˆê¹Œ? (${json.length}ê°œ)`)) {
                        const storageKey = `completed_${currentMapId}`;
                        localStorage.setItem(storageKey, JSON.stringify(json));
                        location.reload();
                    }
                } catch (err) { alert("íŒŒì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤."); }
                input.value = "";
            };
            reader.readAsText(file);
        }

        window.copyToClipboard = function (text) {
            if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(text).catch(() => fallbackCopy(text)); }
        };

        function fallbackCopy(text) {
            const ta = document.createElement("textarea"); ta.value = text;
            ta.style.position = "fixed"; ta.style.left = "0"; ta.style.top = "0";
            document.body.appendChild(ta); ta.focus(); ta.select();
            try { document.execCommand('copy'); } catch (err) { console.error(err); }
            document.body.removeChild(ta);
        }

        // â˜… [ê²½ë¡œ ìš”ì•½] ëª¨ë“  ë§µì˜ ì§„í–‰ë„ë¥¼ í†µí•© ê³„ì‚°
        function updatePathSummaryUI() {
            const container = document.getElementById('path-summary-bar');

            // ê²½ë¡œ ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìˆ¨ê¹€
            if (!currentPathLayer) {
                container.style.display = 'none';
                return;
            }

            const summary = {};

            currentPathIds.forEach(entry => {
                // 1. IDì™€ Map ID ì¶”ì¶œ
                let id, mapId;
                if (typeof entry === 'object') {
                    id = entry.id;
                    mapId = entry.map;
                } else {
                    id = entry;
                    // ê°ì²´ê°€ ì•„ë‹Œ ê²½ìš°, ìºì‹œì—ì„œ ë§µ ì •ë³´ë¥¼ ì°¾ìŒ. ì—†ìœ¼ë©´ í˜„ì¬ ë§µìœ¼ë¡œ ê°€ì •
                    const cachedItem = globalMarkerCache[id];
                    mapId = cachedItem ? cachedItem.map : currentMapId;
                }

                // 2. ì „ì—­ ìºì‹œì—ì„œ ì•„ì´í…œ ì •ë³´ ì¡°íšŒ
                const item = globalMarkerCache[id];

                if (item) {
                    // 3. í•´ë‹¹ ë§ˆì»¤ê°€ ì†í•œ ë§µì˜ ì™„ë£Œ ê¸°ë¡ì„ ê°€ì ¸ì˜´
                    const storageKey = `completed_${mapId}`;
                    const completedList = JSON.parse(localStorage.getItem(storageKey)) || [];

                    if (!summary[item.type]) {
                        summary[item.type] = { total: 0, done: 0 };
                    }
                    summary[item.type].total++;

                    // 4. ì™„ë£Œ ì—¬ë¶€ ì²´í¬
                    if (completedList.includes(id)) {
                        summary[item.type].done++;
                    }
                }
            });

            // HTML ìƒì„±
            const htmlChunks = Object.entries(summary).map(([type, d]) =>
                `<div class="summary-chunk">${type} <b>(${d.done}/${d.total})</b></div>`
            );

            if (htmlChunks.length === 0) {
                container.style.display = 'none';
            } else {
                container.innerHTML = htmlChunks.join('');
                container.style.display = 'flex';
            }
        }
    </script>

</body>

</html>